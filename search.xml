<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>excel常用函数总结</title>
      <link href="/2019/07/20/EXCEL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
      <url>/2019/07/20/EXCEL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-单条件求和——SUMIF-函数"><a href="#1-单条件求和——SUMIF-函数" class="headerlink" title="1.单条件求和——SUMIF 函数"></a>1.单条件求和——SUMIF 函数</h1><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式:"></a>语法格式:</h3><p><code>=sumif(range，criteria，sum_range)</code><br>Sumif（条件区域，求和条件，实际求和区域）<br>注:第二个求和条件参数在第一个条件区域里。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h3><p>统计书店的销售量</p><img src="/.com//SUMIF.jpg"><p>要求是统计鼎盛书店的销量,公式:<br><code>=SUMIF(C3:C636,G4,E3:E636)</code><br>1.条件区域:第一个参数条件区域是c列c3至c636,这里是书店名称</p><p>2.求和条件:第二个参数求和条件是G4,只有在条件区域里满足G4的条件才可以进行求和,而这里的就是只有书店名称是鼎盛书店的才能被求和,其他的则自动忽略</p><p>3.实际求和区域:要在此区域选择满足书店名称等于鼎盛书店的的销量,然后求和</p>]]></content>
      
      
      
        <tags>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>傲娇的寄存器变量</title>
      <link href="/2019/07/19/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2019/07/19/%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>变量通常储存在计算机内存中。如果幸运的话，寄存器变量储存在CPU的寄存器中，或者概括地说，储存在最快的可用内存中。与普通变量相比，访问和处理这些变量的速度更快。由于寄存器变量储存在寄存器而非内存中，所以无法获取寄存器变量的地址。绝大多数方面，寄存器变量和自动变量都一样。也就是说，它们都是块作用域、无链接和自动存储期。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>使用存储类别说明符register便可声明寄存器变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main（<span class="keyword">void</span>)</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> quick;</span><br></pre></td></tr></table></figure><p>我们刚才说“如果幸运的话”，是因为声明变量为register类别与直接命令相比更像是一种请求。编译器必须根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略你的请求，所以可能不会如你所愿。在这种情况下，寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地址运算符。<br>在函数头中使用关键字register，便可请求形参是寄存器变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> macho（<span class="keyword">register</span> <span class="keyword">int</span> n）</span><br></pre></td></tr></table></figure><p>可声明为register的数据类型有限。例如，处理器中的寄存器可能没有足够大的空间来储存double类型的值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
