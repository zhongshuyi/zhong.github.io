<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用Excel中的Power Query合并多个工作簿的数据</title>
      <link href="/2019/09/21/Excel1/"/>
      <url>/2019/09/21/Excel1/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Excel中的Power-Query合并多个工作簿的数据"><a href="#使用Excel中的Power-Query合并多个工作簿的数据" class="headerlink" title="使用Excel中的Power Query合并多个工作簿的数据"></a>使用Excel中的Power Query合并多个工作簿的数据</h1><p>之前老师叫我合并19个工作簿的数据到一张工作簿,当时不懂事,一个个复制,后来去网上查有什么快捷的方法,看到拿VBA的就有点头皮发麻,后来发现excel中的power query可以很快的合并(必须是2016版本以上的才有,如果没有就赶快装一个吧&quot;&gt;</p><p>*<em>准备工作: *</em></p><p><strong>1.一个数据来源文件夹,里面是数据来源,也就是要合并的工作簿</strong></p><p><strong>2.一个合并表,合并后的数据都在这个工作簿里</strong></p><p><strong>注意:合并表不能在数据来源的文件夹</strong></p><img src="/img/Excel1\Image.png"><p><strong>数据来源文件夹里的工作簿有数据</strong></p><img src="/img/Excel1\Image1.png"><p><strong>打开合并工作簿(空的&quot;&gt;,必须先关掉其他工作簿哦!</strong></p><img src="/img/Excel1\Image2.png"><p><strong>打开数据选项卡-&gt;获取数据-&gt;来自文件-&gt;从文件夹</strong></p><img src="/img/Excel1\Image3.png"><p><strong>选择数据来源文件夹</strong></p><p><strong>然后跳转到了Power Query编辑器</strong></p><img src="/img/Excel1\Image4.png">点击转换数据<img src="/img/Excel1\Image5.png"><p><strong>然后右键点击第一列-&gt;选择删除其他列</strong></p><img src="/img/Excel1\Image6.png"><p><strong>点合并文件按钮</strong></p><img src="/img/Excel1\Image7.png">**选择有数据的表**<img src="/img/Excel1\Image8.png"><p><strong>给表起个名字</strong></p><img src="/img/Excel1\Image9.png"><p><strong>选择关闭并上载选项卡,选择下面的关闭并上载至</strong></p><img src="/img/Excel1\Image10.png"><p>随后跳回了合并工作簿</p><img src="/img/Excel1\Image11.png"><p><strong>上面选择表</strong></p><p><strong>下面选择现有工作表或者新工作表都可以</strong></p><p><strong>这样就合并完成啦</strong></p><img src="/img/Excel1\Image12.png">]]></content>
      
      
      <categories>
          
          <category> OFFICE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EXCEL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Office-Tool</title>
      <link href="/2019/09/17/Office-Tool/"/>
      <url>/2019/09/17/Office-Tool/</url>
      
        <content type="html"><![CDATA[<h1 id="Office-Tool"><a href="#Office-Tool" class="headerlink" title="Office Tool"></a>Office Tool</h1><p>在这里安利一个很好用的小工具,就是**Office Tool **</p><p>office是基本每个人都要用到的软件,但正版的微软office太贵,又因为广告不想用金山的WPS,怎么办呢</p><p>接下来推荐一个工具,它集下载,安装以及激活,卸载为一体的小工具,不用安装,轻轻松松安装Office</p><p><a href="https://otp.landian.vip/zh-cn/" target="_blank">下载传送门</a></p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>下载工具后,解压,然后到文件夹中</p><img src="/img/Office-Tool\Image.png"><p>双击Office Tool Plus.exe文件可以执行</p><p>执行后点左边下载选项卡,就可以看到如下页面</p><img src="/img/Office-Tool\Image1.png">选择路径时注意,最好不要有中文路径名,有的话可能会导致错误出现<p>然后底下选择默认的每月通道,因为版本每个月都会更新,选择这个通道就可以安装最新版本了</p><p>体系结构选择X86</p><p>虽然你的电脑是X64位系统的,但是64位的office有一些限制,所以还是安装32位版本的吧</p><p>点击开始即可开始下载</p><h1 id="选择安装包"><a href="#选择安装包" class="headerlink" title="选择安装包"></a>选择安装包</h1><p>下载完后一般会自动选择安装包,如果没有自动选择就在左下角手动选择</p><img src="/img/Office-Tool\Image2.png"><img src="/img/Office-Tool\Image3.png"><img src="/img/Office-Tool\Image4.png"><p>选择这个即可,这是一个完整包</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>选择完成后点击安装选项卡,得到以下界面</p><img src="/img/Office-Tool\Image5.png"><p>office套件选择这个365的就可以,下面的如果不需要就不用选择</p><p>应用程序需要哪些就选择哪些,像我只需要word,excel跟ppt我就只选择这三个,这也是那这个工具安装让我最喜欢的部分,不像网上那些完整的安装包,不需要的一大堆全部安装了,不仅占内存还拖速度</p><img src="/img/Office-Tool\Image6.png"><p>安装模块选择,office tool plus 不然会报错</p><p>选择安装完成后在桌面创建快捷方式</p><p>然后点击右下角的开始安装</p><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><p>等待安装完成后,我们再跳到激活页面</p><img src="/img/Office-Tool\Image7.png"><p>在选择一个证书下面选择一个2019的版本安装,打开你安装的任意一个没有看到要你激活的字样,就表示激活成功,如果还是要你激活就安装过一个证书</p><img src="/img/Office-Tool\Image8.png"><p>这样就安装好了!</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL总笔记</title>
      <link href="/2019/08/22/MYSQL%E6%80%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/08/22/MYSQL%E6%80%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><p>数据库是一个以某种有组织的方式储存的数据集合</p><ol><li><p>表<br>表是一种结构化的文件,可用来存储某种特定类型的数据.(类似于EXCEL表格)<br>表可以保存顾客清单,产品目录,或者其他信息清单<br>在同一个数据库中,表的名字是唯一的,但在不同数据库中表的名字可以相同</p></li><li><p>模式<br>模式是关于数据库和表的布局以及特征的信息</p></li><li><p>列<br>表中的一个字段,所有表都是由一个或多个列组成的</p></li><li><p>数据类型<br>所容许的数据的类型,每个表列都有相应的数据类型,它限制该列中储存的数据</p></li><li><p>行<br>表中的一条记录<br>表中的数据是按行储存的,所保存的每个记录储存在自己的行内,如果表是网格,网格中垂直的为列,水平的为表行</p></li><li><p>主键<br>虽然主键不是必须的,但最好每个表都定义一个主键,主键列有以下特点:<br>主键列不能为NULL(空值)<br>每个主键的值必须唯一,不能与主键上的其他值相同<br>使用主键的好习惯:<br>不更新主键列的值<br>不重用主键列的值<br>不在主键列中使用可能会更改的值</p></li><li><p>SQL<br>SQL结构化查询语言,是一种专门用来与数据库通信的语言</p></li></ol><h1 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h1><h2 id="定义数据库"><a href="#定义数据库" class="headerlink" title="定义数据库"></a>定义数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> &#123; <span class="keyword">database</span> | <span class="keyword">schema</span>&#125; [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名</span><br><span class="line">[ [<span class="keyword">default</span>] <span class="built_in">character</span> <span class="keyword">set</span> [=] 数据库字符集]</span><br><span class="line">[[<span class="keyword">default</span>] <span class="keyword">collate</span> [=] 字符集的校对规则];</span><br></pre></td></tr></table></figure><p>语法说明:</p><ol><li>语句中的<code>[ ]</code>中的为可选项</li><li>语句中的<code>|</code>用于分隔花括号中的选择项,两种选择一种即可,表示”或”关系</li><li>中文的字符集为gb2312,校对规则为gb2312_chinese_ci</li><li>if not exists语句会在创建前进行检查,若该数据库已存在,则不会再创建而导致错误</li></ol><p>实例:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db_shool</span><br><span class="line"><span class="keyword">default</span> <span class="built_in">character</span> <span class="keyword">set</span> gb2312</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">collate</span> gb2312_chinese_ci;</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>在数据库中创建了一个名为db_shool的数据库<br>系统会自动在MySQL的缺省安装路径上例如<br><code>C:\Program Files\MySQL\MySQL Server 5.5\data\performance_schema</code><br>里面新建一个名字为db.opt文件,用于储存所创建数据库的全局特性</p><h3 id="选择与查看数据库"><a href="#选择与查看数据库" class="headerlink" title="选择与查看数据库"></a>选择与查看数据库</h3><ol><li><p>选择数据库<br><code>use 数据库名;</code><br>可以选择你需要操作的数据库,只有选择数据库后才能对数据库进行操作</p></li><li><p>查看数据库<br><code>show {databases | schemas}</code><br>可以查看可用数据库的列表,但只会列出当前用户权限范围内所能查看到的数据库的列表<br>其中除了自己创建的数据库外,有四个系统数据库</p></li></ol><table><thead><tr><th align="center">数据库名称</th><th align="center">数据库作用</th></tr></thead><tbody><tr><td align="center">mysql</td><td align="center">描述用户的访问权限</td></tr><tr><td align="center">information_schema</td><td align="center">保存关于MySQL服务器所维护的所有其他数据库的信息,如数据库名,数据库的表,表字段的数据类型与访问权限等</td></tr><tr><td align="center">performance_schema</td><td align="center">主要用于收集数据库服务器性能参数</td></tr><tr><td align="center">test</td><td align="center">用户利用该数据库进行测试工作</td></tr></tbody></table><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><p>可以修改数据库的 默认字符集以及校对规则</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> &#123; <span class="keyword">database</span> | <span class="keyword">schema</span>&#125; [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名</span><br><span class="line">[<span class="keyword">default</span>] <span class="built_in">character</span> <span class="keyword">set</span> [=] 数据库字符集</span><br><span class="line">[<span class="keyword">default</span>] <span class="keyword">collate</span> [=] 字符集的校对规则;</span><br></pre></td></tr></table></figure><p>注意点:</p><ol><li>此语句用于修改全局特性,也就是数据库目录中的db.opt </li><li>使用此命令时用户必须有修改权限</li><li>数据库名称省略后表示修改当前选中数据库<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2>将已创建的数据库文件夹从磁盘删除,数据库中所有数据将被删除<br><code>drop { database | schema} [if exists] 数据库名</code><br>if exists可以避免数据库不存在时报错</li></ol><h2 id="定义表"><a href="#定义表" class="headerlink" title="定义表"></a>定义表</h2><p>数据表是数据库中最重要,最基本的数据对象,是数据存储的基本单位,若没有表,数据库中的其他数据对象就没有意义</p><h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h3><ol><li>数值类型<img src="/img/数据查询/sjlx.png"></li><li>日期类型<img src="/img/数据查询/sjlx1.png"></li><li>字符串类型<img src="/img/数据查询/sjlx2.png"></li></ol><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>语法:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">(</span><br><span class="line">字段名<span class="number">1</span> 数据类型 [列级完整性约束条件] [默认值]</span><br><span class="line">[, 字段名<span class="number">2</span> 数据类型 [列级完整性约束条件] [默认值] ]</span><br><span class="line">[, ....]</span><br><span class="line">[,表级完整性约束条件]</span><br><span class="line">)[<span class="keyword">engine</span>= 引擎类型];</span><br></pre></td></tr></table></figure><ol><li>创建者必须有表的create权限</li><li><code>[ ]</code>中的参数都是可选参数</li><li>创建多字段必须用逗号隔开,字段名在表中必须唯一</li></ol><h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><ol><li><p>查看所有表名称<br><code>show tables [{from | in} 数据库名];</code><br>{from | in} 数据库名可以显示非当前数据库中的数据库表名称</p></li><li><p>查看表的基本结构<br>查看表的字段名,字段数据类型,字段值是否允许为空,是否为主键,是否有默认值等<br><code>show columns {from | in} 表名 [{from|in}数据库名];</code><br><code>{describe | desc} 表名;</code></p></li><li><p>查看表的详细结构<br><code>show create table 表名 {; | \G}使用</code>\G`结尾可以使信息更清晰</p></li></ol><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>常用:修改字段名或字段数据类型,添加和删除字段,修改字段排练位置,更改表的储存引擎类型,增加和删除表的约束等</p><ol><li><p>添加字段<br>在已有的表中添加字段,可同时添加多个<br><code>alter table 表名 add [column] 新字段名 数据类型  [约束条件] [first | after  已有字段名]</code><br>first表示将字段添加到表的第一个字段<br>after表示添加到指定字段后面一个<br>如果没有这两个参数,默认添加到表的最后一列</p></li><li><p>修改字段<br>change子句:同时修改列名和数据类型,并且可以修改多个(需要逗号隔开)<br><code>alter table 表名 change [column] 原字段名 新字段名 数据类型[约束条件];</code><br>alter子句:修改或删除表中指定列的默认值<br><code>alter table 表名 alter [column] 字段名 {set | drop } default;</code><br>modify子句:修改数据类型或指定列在表中的位置<br><code>alter table 表名 modify [column] 字段名 数据类型 [约束条件] [first | after 已有字段名]</code></p></li><li><p>删除字段<br>在删除列后,原本在该列的数据也会被删除<br><code>alter table 表名 drop [column] 字段名;</code></p></li></ol><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><p><code>alter table 原表名 rename [to] 新表名;</code><br><code>rename  table 原表名1  to 新表名1[,原表名 2  to 新表名2]....;</code><br>rename  table子句可以重命名多个表名</p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p><code>drop table [if exists ] 表1 [,表2]...;</code><br>可以删除多个表<br>if exists 可以判断表是否存在再删除,避免出错</p><h2 id="数据的完整性约束"><a href="#数据的完整性约束" class="headerlink" title="数据的完整性约束"></a>数据的完整性约束</h2><p>完整性规则是对关系的某种约束条件<br>对关系模型施加完整性约束,则是为了数据库应用中保障数据的正确性和一致性,防止数据库中存在不符合语义的不正确的数据,这也是数据库服务器最重要的功能之一<br>完整性约束既能有效防止对MYSQL数据库的意外破坏和非法存取,又能提高完整性检测的效率,还能减轻MySQL编程人员的工作负担</p><h3 id="定义实体完整性"><a href="#定义实体完整性" class="headerlink" title="定义实体完整性"></a>定义实体完整性</h3><p><strong>通过主键约束和候选键约束实现,主属性不能为空</strong></p><h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><ol><li>每个主键的值必须唯一,且不能为null</li><li>每个表只能有一个主键</li><li>复合主键不能包含不必要的多余列</li><li>一个列名在复合主键的列表中只能出现一次</li></ol><p>定义:<br>将字段studentNo定义为主键<br>列级:<br>某个字段后加上关键字primary key<br>例:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_student</span><br><span class="line">(</span><br><span class="line">studentNo <span class="built_in">char</span>(<span class="number">10</span>) primary <span class="keyword">key</span>,</span><br><span class="line">studentName <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">sex <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">birthday <span class="built_in">date</span>,</span><br><span class="line">nation <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">default</span> <span class="string">'汉'</span>,</span><br><span class="line">classNo <span class="built_in">char</span>(<span class="number">6</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br></pre></td></tr></table></figure><p>表级:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_student</span><br><span class="line">(</span><br><span class="line">studentNo <span class="built_in">char</span>(<span class="number">10</span>) ,</span><br><span class="line">studentName <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">sex <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">birthday <span class="built_in">date</span>,</span><br><span class="line">nation <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">default</span> <span class="string">'汉'</span>,</span><br><span class="line">classNo <span class="built_in">char</span>(<span class="number">6</span>),</span><br><span class="line">primary <span class="keyword">key</span>(studentNo)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br></pre></td></tr></table></figure><h4 id="完整性约束的命名"><a href="#完整性约束的命名" class="headerlink" title="完整性约束的命名"></a>完整性约束的命名</h4><p>在<strong>表级完整约束性</strong>前面使用constraint给约束命名<br><code>constraint 约束名字 完整性约束(字段列表)</code></p><h4 id="候选键约束"><a href="#候选键约束" class="headerlink" title="候选键约束"></a>候选键约束</h4><ol><li>候选键可以是某一列,也可以是某些列的组合</li><li>值必须唯一,且不能是null</li></ol><p>定义:<br>与主键约束相似,同样有列级与表级,定义时只是把主键约束的primary key 换成unique即可</p><h3 id="定义参照完整性-外键"><a href="#定义参照完整性-外键" class="headerlink" title="定义参照完整性(外键)"></a>定义参照完整性(外键)</h3><p>参照完整性规则定义的是外键与主键之间的引用规则,既外键的取值或者为空,或者等于被参照关系中的某个主键的值<br>例如有某个年纪的班级列表与某个班级的人员表,学生的班级编号必须是班级列表里已存在的主键值</p><p>注意:</p><ol><li>被参照表必须已创建,或者是当前正在创建,若是后一种,则被参照表与参照表是同一个表,这样的表称为自参照表,这样的结构 ,称为自参照完整性</li><li>必须在被参照表的表名后面指定列名或列名的组合,这个列或列的组合必须是被参照表的主键或候选键</li><li>主键列不能为NULL,但外键可以为空值</li><li>外键对应列的数据类型必须与被参照表的主键对应数据类型相同</li><li>外键只能使用储存引擎InnoDB创建的表中,其他储存引擎不支持外键</li></ol><p>列级方式示例</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_student</span><br><span class="line">(</span><br><span class="line">studentNo <span class="built_in">char</span>(<span class="number">10</span>) ,</span><br><span class="line">studentName <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">sex <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">birthday <span class="built_in">date</span>,</span><br><span class="line">nation <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">default</span> <span class="string">'汉'</span>,</span><br><span class="line">classNo <span class="built_in">char</span>(<span class="number">6</span>) <span class="keyword">references</span> tb_class(classNo),</span><br><span class="line"><span class="keyword">constraint</span> PK_student primary <span class="keyword">key</span>(studentNo)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br></pre></td></tr></table></figure><p>该外键定义成功的前提条件是:<br>tb_class表已存在且classNo字段是该表的主键<br>定义完成后tb_student表中classNo的值必须为tb_class表中主键classNo列的值</p><p>表级方式遵循上面规则</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_student</span><br><span class="line">(</span><br><span class="line">studentNo <span class="built_in">char</span>(<span class="number">10</span>) ,</span><br><span class="line">studentName <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">sex <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">birthday <span class="built_in">date</span>,</span><br><span class="line">nation <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">default</span> <span class="string">'汉'</span>,</span><br><span class="line">classNo <span class="built_in">char</span>(<span class="number">6</span>) ,</span><br><span class="line"><span class="keyword">constraint</span> PK_student primary <span class="keyword">key</span>(studentNo)</span><br><span class="line"><span class="keyword">constraint</span> Fk_student <span class="keyword">foreign</span> <span class="keyword">key</span>(classNo) <span class="keyword">references</span> tb_class(classNo)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br></pre></td></tr></table></figure><p>给外键定义参照动作<br>给外键定义参照动作时，需要包括两部分：一是要指定参照动作适用的语句，即update和delete 语句；二是要指定采取的动作，即 cascade、restrict、set null、no action和setdefault，其中restrict为默认值。具体策略如下：</p><p><code>RESTRICT</code>：限制策略，即当要删除或修改被参照表中被参照列上且在外键中出现的值时，系统拒绝对被参照表的删除或修改操作。<br><code>CASCADE</code>：级联策略，即从被参照表中删除或修改记录时，自动删除或修改参照表中匹配的记录。<br><code>SET NULL</code>：置空策略，即当从被参照表中删除或修改记录时，设置参照表中与之对应的外键列的值为NULL。这个策略需要被参照表中的外键列没有声明限定词NOT NULL。<br><code>NO ACTION</code>：表示不采取实施策略，即当一个相关的外键值在被参照表中时，删除或修改被参照表中键值的动作不被允许。该策略的动作语义与RESTRICT相同。<br><code>SET DEFAULT</code>：默认值策略，即当从被参照表中删除或修改记录行，设置参照表中与之对应的外键列的值为默认值。这个策略要求已经为该列定义了默认值。</p><p>参照动作只需要在定义表时在最后的定义语句之后加上 <code>on 参照动作</code>就可以了</p><h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><p>用户定义的完整性规则反应了某一具体应用所涉及的数据应满足的语义要求<br>例如性别不能为空且只能为男或女</p><ol><li><p>非空约束<br>非空约束是指字段的值不能为空,如果用户在添加数据时没有给其指定值,数据库系统就会报错<br>定义方法:在某个列定义时在后面添加 not null即可</p></li><li><p>check约束<br>check约束需要指定限定条件,可以分表级跟列级,列级可以定义单个字段,表级可以定义多个<br>定义:<br><code>check(表达式);</code><br>可以使用简单表达式也可以使用复杂的表达条件作为限定条件,例如子查询</p></li></ol><h3 id="更新完整性约束"><a href="#更新完整性约束" class="headerlink" title="更新完整性约束"></a>更新完整性约束</h3><p>可以使用alter table 语句更新完整性约束</p><h4 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h4><ol><li><p>删除外键约束<br><code>alter table 表名 drop foreign key 外键约束名</code><br>如果定义时没有指定外键约束名字可以用show create table语句查看系统给外键约束指定的名字</p></li><li><p>删除主键约束<br><code>alter table 表名 drop primary key;</code><br>因为主键一个表中只能定义一个所以可以不使用名字</p></li><li><p>删除候选键约束<br>删除候选键约束时,实际删除的的唯一性索引,应使用drop index子句删除,若没有给定约束名,MySQL自动将字段名定义成索引名<br><code>alter table 表名 drop index {约束名 | 候选键字段名};</code></p></li></ol><h4 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h4><p>可以使用alter table语句添加完整性约束</p><ol><li><p>添加主键约束<br><code>alter table 表名 add [constraint 约束名] primary key(主键字段);</code></p></li><li><p>添加外键约束<br><code>alter table 表名 add [constraint 约束名] foreign key(外键字段名)  references  被参照表(主键字段名);</code></p></li><li><p>添加候选键约束<br><code>alter table 表名 add [constraint 约束名] unique key(字段名);</code></p></li></ol><h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><h2 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h2><p>设已定义表</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image.png" alt></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image1.png" alt></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image2.png" alt></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image3.png" alt><br>表中有数据</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image4.png" alt></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image5.png" alt></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image6.png" alt></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image7.png" alt></p><p>使用select语句可以在需要时从数据库中快捷方便地检索,统计或输入数据</p><p>语法:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">all</span> | <span class="keyword">distinct</span> | <span class="keyword">distinctrow</span> ]&lt;目标列表达式<span class="number">1</span>&gt;[,&lt;目标列表达式<span class="number">2</span>&gt;]..</span><br><span class="line"><span class="keyword">form</span>  &lt;表名<span class="number">1</span>或视图名&gt;[,表名<span class="number">2</span>或视图名<span class="number">2</span>&gt;]..</span><br><span class="line">[<span class="keyword">where</span>&lt;条件表达式&gt;]</span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span> &lt;列名<span class="number">1</span>&gt; [<span class="keyword">having</span>&lt;条件表达式&gt;]]</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span> &lt;列名<span class="number">2</span>&gt; [<span class="keyword">asc</span>  |  <span class="keyword">desc</span>]]</span><br><span class="line">[<span class="keyword">limit</span>[m,]  n ]</span><br></pre></td></tr></table></figure><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="查询指定字段"><a href="#查询指定字段" class="headerlink" title="查询指定字段"></a>查询指定字段</h3><p>语法:</p><p> <code>select  目标列表达式1,目标列表达式2,...目标列表达式n  from 表名;</code> </p><p>例子</p><p>从班级表tb_class查询所有班级的班级编号、所属学院和班级名称</p><p> <code>select  classno,depatment,classname from tb_class</code> </p><p>该查询执行的过程是:</p><p>首先从tb_class表中依次取出每条记录,然后对每条记录仅选取classno,depatment,和classname三个字段的值,形成一条新纪录,最后将这些新纪录组织为一个结果表输出</p><p><img src="%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%5CImage8.png" alt></p><h3 id="查询所有字段"><a href="#查询所有字段" class="headerlink" title="查询所有字段"></a>查询所有字段</h3><p>查询所有字段有两种方法,一种是将所有的字段在select后面列出来,一种是在select后面加 `*`号</p><p>我们当然是选择比较方便的一种,加`*`号,此时结果集各列的次序与这些列在表定义中出现的顺序一致</p><p>语法:</p><p> <code>select * from tb_class</code> </p><h3 id="查询经过计算的值"><a href="#查询经过计算的值" class="headerlink" title="查询经过计算的值"></a>查询经过计算的值</h3><p>语法:</p><p> <code>select  字段或表达式1,字段或表达式2... from 表名</code> </p><p>查询的可以是表达式,也可以是函数和字段名</p><h3 id="定义字段的别名"><a href="#定义字段的别名" class="headerlink" title="定义字段的别名"></a>定义字段的别名</h3><p>若希望列的名称显示为自定义的列名时,可以通过给列取别名的方式实现</p><p>语法:</p><p><code>字段名 [AS] 字段别名</code></p><p>AS是可选字段,也可以直接省略AS,直接用空格隔开 ,<code>字段名 字段别名</code></p><p>例子:从学生表tb_student查询全体学生的姓名、性别和年龄，要求分别以别名‘姓名’、‘性别’和‘年龄’显示</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image9.png" alt></p><p>详解:</p><p>先查询studentname与sex列,再计算 <code>year(now())-year(birthday)</code> 表达式,这里用到两个函数</p><p>year函数:返回参数中年的部分,例如<code>year(2019-01-01)</code>的结果是2019</p><p>now函数:无参数,返回现在的系统时间</p><p>使用现在系统的年减去生日列的年得到年龄</p><p>as后跟着的是这个列的别名,在查询后得到的结果表头不会太长</p><h3 id="带条件的查询"><a href="#带条件的查询" class="headerlink" title="带条件的查询"></a>带条件的查询</h3><p>select语句中可以使用where子句中指定的过滤条件,从from子句的中间结果中选取适当的行,实现数据的过滤</p><p>语法:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 目标列表达式<span class="number">1</span>,目标列表达式<span class="number">2</span>,...目标列表达式n</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">where</span> 查询条件;</span><br></pre></td></tr></table></figure><p>常用查询条件</p><table><thead><tr><th align="center">查询条件</th><th align="center">操作符</th></tr></thead><tbody><tr><td align="center">比较</td><td align="center"><code>=,&lt;&gt;,!=,&lt;,&lt;=,&gt;,&gt;=,!&lt;,!&gt;,not+含比较运算符的表达式</code></td></tr><tr><td align="center">确定范围</td><td align="center">between and,not between and</td></tr><tr><td align="center">字符匹配</td><td align="center">like,not like</td></tr><tr><td align="center">空值</td><td align="center">is null ,is not null</td></tr><tr><td align="center">多重条件</td><td align="center">and ,or</td></tr></tbody></table><h4 id="比较查询"><a href="#比较查询" class="headerlink" title="比较查询"></a>比较查询</h4><p>比较运算符用于指定目标列表达式的值,当目标列表达式的值与指定值相等时,返回逻辑值真,否则返回假</p><p>例子:<br> 从学生表tb_student查询学号为2013110201的学生的详细情况</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image10.png" alt></p><p>题中要求查询学号为2013110201的学生的所有消息,所以使用返回全部列的表达式,<code>select*from</code></p><p>要求是学号为2013110201,所以where后面跟着的条件为 student=’2013110201’</p><h4 id="确定范围的查询"><a href="#确定范围的查询" class="headerlink" title="确定范围的查询"></a>确定范围的查询</h4><p>当查询条件被限制在某个范围,可以使用between…and</p><p>语法:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 目标列表达式<span class="number">1</span>,目标列表达式<span class="number">2</span>,...目标列表达式n</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">where</span> 指定列 [<span class="keyword">not</span>] <span class="keyword">between</span> 值<span class="number">1</span>  <span class="keyword">and</span> 值<span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以查询指定列满足值1和值2之间的数据,但包含这两个值,例如在20到30之间包含20和30</p><p>例</p><p>从学生表tb_student查询年龄在20到23岁之间的学生姓名、性别、年龄</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image11.png" alt></p><p>使用函数计算年龄,然后起个别名,过滤条件是计算的年龄在20和30之间并包含20和30</p><p>若是between and 前面加了关键字 not 则表示不在这个范围内,并且不包含这两个值</p><h4 id="带in的集合查询"><a href="#带in的集合查询" class="headerlink" title="带in的集合查询"></a>带in的集合查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 目标列表达式<span class="number">1</span>,目标列表达式<span class="number">2</span>,...目标列表达式n</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">where</span> 指定列 <span class="keyword">in</span> (值,值,值)</span><br></pre></td></tr></table></figure><p>集合内的值用逗号隔开</p><p>只要满足一个值,就返回结果</p><p>例子</p><p>从学生表tb_student查询籍贯是北京、天津和上海的学生信息</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image12.png" alt></p><p>例子查询了籍贯北京,上海,天津只要是满足任意一个就可以</p><p>带not关键字的</p><p>从学生表tb_student查询籍贯不是北京、天津的学生信息</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image13.png" alt></p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>关键字like 用于字符串的匹配</p><p>语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 目标列表达式<span class="number">1</span>,目标列表达式<span class="number">2</span>,...目标列表达式n</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">where</span> 指定列 [<span class="keyword">not</span>] <span class="keyword">like</span> <span class="string">'&lt;匹配串&gt;'</span></span><br></pre></td></tr></table></figure><p>查找指定字段与的值与&lt;匹配串&gt;相匹配的记录,匹配串可以是一个完整的常字符串,也可以含有通配符</p><p>常用通配符</p><p>`%`:代表任意长度的字符串,甚至长度为零的字符</p><p>‘_‘:代表任意单个字符</p><p>例子:</p><p>从学生表tb_student查询所有姓“王”的学生的学号、姓名和班号</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image14.png" alt><br>例子使用%通配符查询了所有姓王的同学的部分信息,无论名字是几个字</p><p>使用not关键字</p><p>从学生表tb_student查询所有不姓“江”的学生的学号、姓名和班号</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image15.png" alt></p><p>查询所有包含’林’字的<code>where studentname like &#39;%林%</code></p><h4 id="查询是否是空值"><a href="#查询是否是空值" class="headerlink" title="查询是否是空值"></a>查询是否是空值</h4><p>空值一般表示数据未知,不确定或以后再添加.空值不等于0,也不同于字符串.</p><p>当需要查询某字段内容是否为空值时,可以使用关键字IS  NULL 来实现</p><p>例子<br>从课程表tb_course查询缺少先修课的课程信息;</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/Image16.png" alt></p><p>另外,可以用IS NOT  NULL查找字段值不为空的记录</p><h4 id="带AND或OR的多条件查询"><a href="#带AND或OR的多条件查询" class="headerlink" title="带AND或OR的多条件查询"></a>带AND或OR的多条件查询</h4><p>and和or可以用来连接多个查询条件</p><p>and限定必须满足所以条件的记录才会返回</p><p>or表示只要满足其中一个查询条件就会被返回</p><p>and 的优先级高于or,可以使用括号改变优先级</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 目标列表达式<span class="number">1</span>,目标列表达式<span class="number">2</span>,...目标列表达式n</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">where</span> 条件<span class="number">1</span>  <span class="keyword">OR</span> | <span class="keyword">AND</span> 条件<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h4><p>如果想对查询的结果以某个字段进行排序,可以使用order by子句</p><p>语法:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 目标列表达式<span class="number">1</span>,目标列表达式<span class="number">2</span>,...目标列表达式n</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 字段名 [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p>order by 后面跟着的是要排序的字段名</p><p>ASC 是表示按升序排序</p><p>DESC 表示按降序排序</p><p>如果没有指定升序还是降序,则默认按升序</p><p>如果排序的字段是中文,则按拼音的字母顺序进行排序</p><h4 id="限制记录查询"><a href="#限制记录查询" class="headerlink" title="限制记录查询"></a>限制记录查询</h4><p>如果记录太多,只想查询前面几行,或者从第几行开始显示几行,这个时候可以使用限制记录查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 目标列表达式<span class="number">1</span>,目标列表达式<span class="number">2</span>,...目标列表达式n</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">limit</span> [位置偏移量,]行数;</span><br></pre></td></tr></table></figure><p>位置偏移量:默认值为0,表示从第一行开始显示,如果位置偏移量为1,则表示从第二行开始显示,以此类推</p><p>行数:表示要显示的行数,要显示多少行就写多少行</p><p><strong>注意:</strong></p><ol><li><strong>行数必须为非负的整数常量,若指定行数大于实际有的行数,则只能返回实际有的行数</strong></li><li><strong>如果既有order by 子句,又有limit子句,则limit子句必须在order by 子句之后</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>换系统</title>
      <link href="/2019/08/19/%E6%8D%A2%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/08/19/%E6%8D%A2%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>电脑系统如果崩了，或者你错误的删了一些电脑系统盘里的东西需要换一个系统，去店里得五十块，这个时候如果自己会装系统就可以轻松省下这一笔钱了</p><p>由于网上PE装机教程一抓一大把,所以今天来教一个不一样的：直接将ISO镜像文件写入U盘，写入后直接插u盘可以装系统，不用进入PE，方便至极，而且U盘空余的空间可以存其他东西</p><h1 id="准备材料："><a href="#准备材料：" class="headerlink" title="准备材料："></a>准备材料：</h1><ol><li>一个U盘（4G以上吧）</li><li>软碟通：<br>链接：<a href="https://pan.baidu.com/s/1b_W2bjMQKYMpUGIVq2Sf9Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1b_W2bjMQKYMpUGIVq2Sf9Q</a><br>提取码：vez5 </li><li>一个系统的镜像文件：<br>简体中文版：链接： <a href="https://pan.baidu.com/s/10PnW8lpBZC1niqi0Y1jdyA" target="_blank" rel="noopener">https://pan.baidu.com/s/10PnW8lpBZC1niqi0Y1jdyA</a> 提取码：8lpw<br>简体中文专业版：链接：<a href="https://pan.baidu.com/s/1SD2FEtHUK28CMvlv_eZt1A" target="_blank" rel="noopener">https://pan.baidu.com/s/1SD2FEtHUK28CMvlv_eZt1A</a> 提取243f <pre><code>安装密钥：VK7JG-NPHTM-C97JM-9MPGT-3V66T </code></pre>企业版：链接：<a href="https://pan.baidu.com/s/1pNWag6Qvxb7rBLQDZYQndg" target="_blank" rel="noopener">https://pan.baidu.com/s/1pNWag6Qvxb7rBLQDZYQndg</a> 提取码：lis2</li></ol><p>版本自行选择</p><h1 id="安装软碟通（注册码文件内有"><a href="#安装软碟通（注册码文件内有" class="headerlink" title="安装软碟通（注册码文件内有)"></a>安装软碟通（注册码文件内有)</h1><h1 id="打开系统映像"><a href="#打开系统映像" class="headerlink" title="打开系统映像"></a>打开系统映像</h1><p>双击打开<strong>（因为安装软碟通后设置了文件关联，可以直接打开ISO文件跳至软碟通）</strong><br><img src="/img/装系统/ZXT1.png"><br><img src="/img/装系统/ZXT2.png"></p><h1 id="插入U盘-最少8个g"><a href="#插入U盘-最少8个g" class="headerlink" title="插入U盘(最少8个g)"></a>插入U盘(最少8个g)</h1><h1 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h1><p>点启动里的写入硬盘映像<br><img src="/img/装系统/ZXT3.png"><br>然后点写入<br><img src="/img/装系统/ZXT4.png"></p><p>#</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java总笔记</title>
      <link href="/2019/08/17/Java%E6%80%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/08/17/Java%E6%80%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="java运行原理"><a href="#java运行原理" class="headerlink" title="java运行原理"></a>java运行原理</h1><p><strong>java编译器 (编译) → 虚拟机(解释执行) → 解释器(翻译) → 机器码</strong></p><p>Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。</p><h2 id="Java虚拟机-JVM"><a href="#Java虚拟机-JVM" class="headerlink" title="Java虚拟机(JVM)"></a>Java虚拟机(JVM)</h2><p>java虚拟机是一个虚构出来的计算机,是通过在实际的计算机上仿真模拟各种计算机功能来模拟实现的</p><p>Java中，类加载器把一个类装入JAVA虚拟机需要经过三个步骤来完成：<strong>装载、链接、初始化</strong>，其中链接又分来校验、准备、解析过程</p><ol><li><p>装载：查找和导入.class文件</p></li><li><p>链接：检查装入.class文件的正确性，然后，java虚拟机为变量分配内存，设置默认值</p></li><li><p>初始化：把符号引用变成直接引用</p></li></ol><hr><h1 id="Java程序设计环境"><a href="#Java程序设计环境" class="headerlink" title="Java程序设计环境"></a>Java程序设计环境</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><strong>下载jdk</strong><br>链接：<a href="https://pan.baidu.com/s/158xbJW96bKMMVxGtU7cB8w" target="_blank" rel="noopener">https://pan.baidu.com/s/158xbJW96bKMMVxGtU7cB8w</a><br>提取码：r1u9 </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><img src="/img/java总笔记/JDK1.png">**狂点下一步**安装到默认的C:\Program Files\Java\jdk1.8.0_131目录<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ol><li><p><strong>此电脑-&gt;右键,属性</strong></p></li><li><p><strong>-&gt;左上角列表,高级系统设置-&gt;</strong></p><img src="/img/java总笔记/HJ1.png"></li><li><p><strong>环境变量-&gt;</strong></p><img src="/img/java总笔记/HJ2.png"></li><li><p><strong>下方系统变量-&gt;选择Path变量-&gt;编辑</strong></p><img src="/img/java总笔记/HJ3.png"></li><li><p><strong>-&gt;新建</strong></p></li></ol><p><strong>-&gt;将jdk的bin目录路径C:\Program Files\Java\jdk1.8.0_131\bin复制到目录</strong><br><img src="/img/java总笔记/HJ4.png"></p><ol start="6"><li><strong>全部按确定,直至退出</strong></li></ol><h2 id="检查环境是否配置完成"><a href="#检查环境是否配置完成" class="headerlink" title="检查环境是否配置完成"></a>检查环境是否配置完成</h2><p>在命令行中检查环境变量是否配置成功<br>在cmd中输入Java回车出现如下信息<br><img src="/img/java总笔记/HJ5.png"><br>在cmd中输入Javac回车出现如下信息<br><img src="/img/java总笔记/HJ6.png"><br>配置完成</p><h2 id="JAVA-HOME"><a href="#JAVA-HOME" class="headerlink" title="JAVA_HOME"></a>JAVA_HOME</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><ol><li><p>为了方便引用<br>比如，你JDK安装在C:\ProgramFiles\Java\jdk1.7.0目录里，则设置JAVA_HOME为该目录路径, 那么以后你要使用这个路径的时候, 只需输入%JAVA_HOME%即可,避免每次引用都输入很长的路径串;</p></li><li><p>归一原则<br>当你JDK路径被迫改变的时候, 你仅需更改JAVA_HOME的变量值即可, 否则,你就要更改任何用绝对路径引用JDK目录的文档</p></li><li><p>第三方软件会引用约定好的JAVA_HOME变量, 不然, 你将不能正常使用该软件,</p></li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li>在系统变量中新建一个JAVA_HOME变量,值是jdk的目录,<strong>注意:是jdk的目录,不是jdk里面的bin目录</strong>若是以后安装其他版本的jdk,直接添加jdk的目录至JAVA_HOME即可<br><code>C:\Program Files\Java\jdk1.8.0_131</code><img src="/img/java总笔记/HJ8.png"><img src="/img/java总笔记/HJ7.png"></li><li>在Path变量里面新建一个值,值是<code>%JAVA_HOME%\bin</code>(也表示jdk里面的bin目录)<img src="/img/java总笔记/HJ9.png"></li></ol><hr><h1 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a>第一个Java程序</h1><h2 id="命令行编译Java程序"><a href="#命令行编译Java程序" class="headerlink" title="命令行编译Java程序"></a>命令行编译Java程序</h2><ol><li><p>进入D盘或者其他文件夹</p></li><li><p>在这个目录新建一个Hello.txt的文本文档</p></li><li><p>输入下面代码</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hello</span>&#123;<span class="comment">//文件名与文件名一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"你好,世界!"</span>);<span class="comment">//注意大小写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>把后缀名改为<strong>.java</strong></p><img src="/img/java总笔记/DYJAVA2.png"></li><li><p>打开cmd</p></li></ol><p>可以直接在文件路径那里输入cmd可以直接在命令行中进入此文件夹<br><img src="/img/java总笔记/DYJAVA3.png"></p><ol start="6"><li>打开后输入Javac Hello.java按回车</li></ol><p>输入Java Hello</p><p>得到 “你好,世界”</p><p>第一个Java程序运行完成</p><h2 id="eclipse集成开发环境"><a href="#eclipse集成开发环境" class="headerlink" title="eclipse集成开发环境"></a>eclipse集成开发环境</h2><ol><li><p>打开此文件夹(已汉化)</p><img src="/img/java总笔记/DYJAVA4.png"></li><li><p>双击eclipse.exe</p><img src="/img/java总笔记/DYJAVA5.png"></li><li><p>选择一个工作空间,保存以后的Java项目</p></li><li><p>点击文件,新建,Java项目</p><img src="/img/java总笔记/DYJAVA6.png"></li><li><p>在项目src文件夹里右键新建包,起个名字,包名所有字母小写</p><img src="/img/java总笔记/DYJAVA7.png"><img src="/img/java总笔记/DYJAVA8.png"></li><li><p>在新建的包右键点击,新建类,自动完成以下代码</p><img src="/img/java总笔记/DYJAVA9.png"></li><li><p>将前面的代码填充到代码区</p><img src="/img/java总笔记/DYJAVA11.png"></li><li><p>按ctrl+F11就可以运行<br>在下方控制台窗口就可以看到输出了</p><img src="/img/java总笔记/DYJAVA10.png"></li></ol><hr><h1 id="java的基本程序设计结构"><a href="#java的基本程序设计结构" class="headerlink" title="java的基本程序设计结构"></a>java的基本程序设计结构</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>有三种注释:单行注释,多行注释与文档注释</p><ol><li>单行注释//,最常用的注释其注释内容从 // 开始到本行结尾。 </li><li>多行注释 从<code>/*</code>开始直至第一个<code>*/</code>出现都属于多行注释,但多行注释不能嵌套,多行注释也可以注释掉不需要的代码</li><li>文档注释 可以自动地生成文档,这种注释以<code>/**</code>开始,以<code>*/</code>结束<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这就是传说中的多行注释</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 作者</span></span><br><span class="line"><span class="comment"> *可以自动生成文档</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"你好"</span>);<span class="comment">//这是单行注释</span></span><br><span class="line"><span class="comment">/*  System.out.println("你好");</span></span><br><span class="line"><span class="comment">System.out.println("你好");</span></span><br><span class="line"><span class="comment">这里都是多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在 Java 中， -共有 8 种基本类型（primitive type), 其中有 4 种整型、2 种浮点类型、 1 种用于表示 Unicode编码的字符 单元的字符类型 char和 1 种用于表示真值的 boolean类型</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>整型用于表示没有小数部分的数值,它允许是负数</p><table><thead><tr><th align="center">类型</th><th align="center">储存需求</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">4字节</td><td align="center">-2147483648-2147483647 (正好超过 20亿)</td></tr><tr><td align="center">short</td><td align="center">2字节</td><td align="center">-32768-32767</td></tr><tr><td align="center">long</td><td align="center">8字节</td><td align="center">-9223372036854775808-9223372036854775807</td></tr><tr><td align="center">byte</td><td align="center">1字节</td><td align="center">-127-127</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> INT = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">short</span> SHORT = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">long</span> LONG= <span class="number">8</span>;</span><br><span class="line"><span class="keyword">byte</span> BYTE=<span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">"int类型占用"</span>+INT+<span class="string">"字节"</span>);</span><br><span class="line">System.out.println(<span class="string">"short类型占用"</span>+SHORT+<span class="string">"字节"</span>);</span><br><span class="line">System.out.println(<span class="string">"LONG类型占用"</span>+LONG+<span class="string">"字节"</span>);</span><br><span class="line">System.out.println(<span class="string">"bate类型占用"</span>+ BYTE +<span class="string">"字节"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">int类型占用<span class="number">4</span>字节</span><br><span class="line">short类型占用<span class="number">2</span>字节</span><br><span class="line">LONG类型占用<span class="number">8</span>字节</span><br><span class="line">bate类型占用<span class="number">1</span>字节</span><br></pre></td></tr></table></figure><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点类型用于表示有小数部分的数值,在 Java中有两种浮点类型</p><table><thead><tr><th>类型</th><th align="center">储存需求</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td align="center">4字节</td><td>大约 ± 3.402 82347E+38F (有效位数为 6 ~ 7 位）</td></tr><tr><td>double</td><td align="center">8字节</td><td>大约 ± 1.797693 134862315 70E+308 (有效位数为 15 位)</td></tr></tbody></table><p>double 表示这种类型的数值精度是 float 类型的两倍（有人称之为双精度数值)。绝大部分应用程序都采用double 类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">float</span> FAULT = <span class="number">3.1415926F</span>;<span class="comment">//数值后</span></span><br><span class="line"><span class="keyword">double</span> DOUBLE = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"float类型:"</span>+FAULT);<span class="comment">//最多7位</span></span><br><span class="line">System.out.println(<span class="string">"double类型:"</span>+DOUBLE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>char 类型原本用于表示单个字符。不过，现在情况已经有所变化如今有些 Unicode 字符可以用一个 chai值描述，另外一些 Unicode 字符则需要两个 char 值</p><p>char类型占两个字节</p><p>char类型的字面量值要用单引号括起来<br>特殊字符转义序列</p><table><thead><tr><th align="center">转义序列</th><th align="center">名称</th><th align="center">Unicode值</th></tr></thead><tbody><tr><td align="center">\b</td><td align="center">退格</td><td align="center">\u0008</td></tr><tr><td align="center">\t</td><td align="center">制表符</td><td align="center">\u0009</td></tr><tr><td align="center">\n</td><td align="center">换行</td><td align="center">\u000a</td></tr><tr><td align="center">\r</td><td align="center">回车</td><td align="center">\u000d</td></tr><tr><td align="center">&quot;</td><td align="center">双引号</td><td align="center">\u0022</td></tr><tr><td align="center">&#39;</td><td align="center">单引号</td><td align="center">\u0027</td></tr><tr><td align="center">\</td><td align="center">反斜杠</td><td align="center">\u005c</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'1'</span>;</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'男'</span>;<span class="comment">//单个汉字也可以存为char类型</span></span><br><span class="line"><span class="keyword">char</span> d = <span class="string">'\t'</span>;<span class="comment">//制表符相当于按tab键</span></span><br><span class="line">System.out.print(a);</span><br><span class="line">System.out.print(b);</span><br><span class="line">System.out.print(d);</span><br><span class="line">System.out.print(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:<br><code>1A    男</code></p><p>Boolean类型<br>boolean (布尔）类型有两个值：false 和 true,用来判定逻辑条件整型值和布尔值之间不能进行相互转换,这点不同于c语言</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量声明语法:<br>`数据类型 变量名 [= 变量值];’<br>变量名遵循以下规则:</p><ol><li>首字符必须是字母、下划线（―）、美元符号（$）或者人民币符号（¥）。</li><li>标识符由数字（0<del>9）、大写字母（A</del>Z）、小写字母（a~z）、下划线（―）、美元符号（$）、人民币符号（¥）以及所有在十六进制 0xc0 前的 ASCII 码组成。</li><li>不能把关键字、保留字作为标识符。</li><li>标识符的长度没有限制。</li><li>标识符区分大小写。</li></ol><p>变量声明可以一行声明多个变量<br><code>int i , j;//一行声明i和j两个变量</code><br><strong>不过不提倡,使用这种风格,逐一声明一个变量可以提高程序的可读性</strong></p><p>变量的初始化<br>可以先声明后初始化<br><code>int i;</code><br><code>i=8</code><br>也可以声明的时候初始化<br><code>int i = 8;</code></p><p><strong>在Java中,变量的声明尽量靠近第一次使用的地方,这是一种良好的程序编写风格</strong></p><h2 id="常量值"><a href="#常量值" class="headerlink" title="常量值"></a>常量值</h2><p>常量值又称为字面常量，它是通过数据直接表示的</p><h3 id="整型常量值"><a href="#整型常量值" class="headerlink" title="整型常量值:"></a>整型常量值:</h3><ol><li>十进制数形式：如 54、-67、0。</li><li>八进制数形式：Java 中的八进制常数的表示以 0 开头，如 0125 表示十进制数 85，-013 表示十进制数 -11。</li><li>十六进制数形式：Java 中的十六进制常数的表示以 0x 或 0X 开头，如 0x100 表示十进制数 256，-0x16 表示十进制数 -22。</li></ol><h3 id="实型常量值"><a href="#实型常量值" class="headerlink" title="实型常量值:"></a>实型常量值:</h3><ol><li>十进制数形式：由数字和小数点组成，且必须有小数点，如 12.34、-98.0。</li><li>科学记数法形式：如 1.75e5 或 32&amp;E3，其中 e 或 E 之前必须有数字，且 e 或 E 之后的数字必须为整数。</li></ol><h3 id="布尔型常量值"><a href="#布尔型常量值" class="headerlink" title="布尔型常量值"></a>布尔型常量值</h3><p>Java 的布尔型常量只有两个值，即 false（假）和 true（真）。</p><h3 id="字符型和字符串常量值"><a href="#字符型和字符串常量值" class="headerlink" title="字符型和字符串常量值"></a>字符型和字符串常量值</h3><p>Java 的字符型常量值是用单引号引起来的一个字符，如 ‘e’、E’。需要注意的是，Java 字符串常量值中的单引号和双引号不可混用。双引号用来表示字符串，像 “11”、”d” 等都是表示单个字符的字符串。</p><h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><p>java中,利用关键字 final 指示常量<br><code>final double ZHONG=3.1415;</code><br>关键字final表示这个变量只能被赋值一次,一旦被赋值后就不能再更改了<br><strong>习惯上,常量名使用全大写</strong></p><h3 id="数据类型之间的转换"><a href="#数据类型之间的转换" class="headerlink" title="数据类型之间的转换"></a>数据类型之间的转换</h3><p>自动类型转换:<br>当使用上面两个数值进行二元操作时（例如 n + f，n 是整数，f 是浮点数)， 先要将两个<br>操作数转换为同一种类型，然后再进行计算。</p><ol><li>如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。</li><li>否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。 </li><li>否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。</li><li>否则， 两个操作数都将被转换为 int 类型。 </li></ol><p>强制类型转换<br>语法:`(目标类型)待转换变量名’ </p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符按照操作数的数量可以分为单目运算符、双目运算符和三目运算符。<br>最基本的运算符包括算术运算符、赋值运算符、逻辑运算符和关系运算符等<br>算术运算符都是双目运算符，即连接两个操作数的运算符。优先级上，*、/、％ 具有相同运算级别，并高于 +、-（+、- 具有相同级别）。</p><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>注意点:</p><ol><li>求余（％）运算要求参与运算的两个操作数均为整型，不能为其他类型。</li><li>两个整数进行除法运算，其结果仍为整数。如果整数与实数进行除法运算，则结果为实数。</li><li>Java 语言算术运算符的优先级是先乘除后加减</li></ol><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>语法:<code>变量名称=表达式内容</code><br>赋值运算符的优先级低于算术运算符，结合方向是自右向左<br>不要将赋值运算符与相等运算符“==”混淆。</p><p>赋值运算符和算数运算符组成的复合赋值运算</p><table><thead><tr><th align="center">运算符</th><th align="center">含义</th><th align="center">实例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">+=</td><td align="center">将该运算符左边的数值加上右边的数值,其结果赋值给左边变量本身</td><td align="center">int a=5;a+=2;</td><td align="center">a=7</td></tr><tr><td align="center">-=</td><td align="center">将该运算符左边的数值减去右边的数值,其结果赋值给左边变量本身</td><td align="center">int a=5;a-=2;</td><td align="center">a=3</td></tr><tr><td align="center">*=</td><td align="center">将该运算符左边的数值乘以右边的数值,其结果赋值给左边变量本身</td><td align="center">int a=5;a*=2;</td><td align="center">a=10</td></tr><tr><td align="center">/=</td><td align="center">将该运算符左边的数值整除右边的数值,其结果赋值给左边变量本身</td><td align="center">int a=5;a/=2;</td><td align="center">a=2</td></tr><tr><td align="center">%=</td><td align="center">将该运算符左边的数值除以右边的数值后取余,其结果赋值给左边变量本身</td><td align="center">int a=5; a%=2;</td><td align="center">a=1</td></tr></tbody></table><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符是二元运算符，运算结果是 boolean 型。当运算符对应的关系成立时，运算结果是 true，否则是 false。</p><table><thead><tr><th align="center">运算符</th><th align="center">含义</th><th align="center">实例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">&gt;</td><td align="center">大于运算符</td><td align="center">2&gt;3</td><td align="center">false</td></tr><tr><td align="center">&gt;=</td><td align="center">大于或等于运算符</td><td align="center">4&gt;=2</td><td align="center">true</td></tr><tr><td align="center">&lt;</td><td align="center">小于运算符</td><td align="center">2&lt;3</td><td align="center">true</td></tr><tr><td align="center">&lt;=</td><td align="center">小于或等于运算符</td><td align="center">4&lt;=2</td><td align="center">false</td></tr><tr><td align="center">==</td><td align="center">相等运算符</td><td align="center">4==4</td><td align="center">true</td></tr><tr><td align="center">!=</td><td align="center">不相等运算符</td><td align="center">4!=2</td><td align="center">true</td></tr></tbody></table><p>关系运算符的优先级为：&gt;、&lt;、&gt;=、&lt;= 具有相同的优先级，并且高于具有相同优先级的 !=、==。关系运算符的优先级高于赋值运算符而低于算术运算符，结合方向是自左向右。</p><p>关系表达式通常用于 Java 程序的逻辑判断语句的条件表达式中<br><strong>注意点:</strong></p><ol><li>运算符 &gt;=、==、！=、&lt;= 是两个字符构成的一个运算符，用空格从中分开写就会产生语法错误。例如 x&gt; =y; 是错误的，但是可以写成 x&gt;=y; 在运算符的两侧增加空格会提高可读性。同样将运算符写反，例如 =&gt;、=&lt;、=! 等形式会产生语法错误。</li><li>由于计算机内存放的实数与实际的实数存在着一定的误差，如果对浮点数进行 ==（相等）或 !=（不相等）的比较，容易产生错误结果，应该尽量避免。</li><li>不要将“==”写成“=”。</li></ol><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p>++ 或 – 是单目运算符，放在操作数的前面或后面都是允许的。++ 与 – 的作用是使变量的值增 1 或减 1。操作数必须是一个整型或浮点型变量。</p><table><thead><tr><th align="center">运算符</th><th align="center">含义</th><th align="center">实例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">i++</td><td align="center">将 i 的值先使用再加1赋值给i变量本身</td><td align="center">int i=1;int j=i++;</td><td align="center">i=2 j=1</td></tr><tr><td align="center">++i</td><td align="center">将 i 的值先加1赋值给变量i本身后再使用</td><td align="center">int i=1;int j=++i;</td><td align="center">i=2 j=2</td></tr><tr><td align="center">i--</td><td align="center">将 i 的值先使用再减1赋值给变量i本身</td><td align="center">int i=1;int j=i--;</td><td align="center">i=0 j=1</td></tr><tr><td align="center">--i</td><td align="center">将 i 的值先减1后赋值给变量 i 本身再使用</td><td align="center">int i=1;int j=--i;</td><td align="center">i=0 j=0</td></tr></tbody></table><p><strong>注意点:</strong></p><ol><li>自增/自减只能作用于变量，不允许对常量、表达式或其他类型的变量进行操作。常见的错误是试图将自增或自减运算符用于非简单变量表达式中。</li><li>自增/自减运算可以用于整数类型 byte、short、int、long，浮点类型 float、double，以及字符串类型 char。</li><li>在 Java 1.5 以上版本中，自增/自减运算可以用于基本类型对应的包装器类 Byte、Short、Integer、Long、Float、Double 和 Character。</li><li>自增/自减运算结果的类型与被运算的变量类型相同。</li><li>建议不要在表达式中使用++, 因为这样的代码很容易让人困惑，而且会带来烦人的 bug</li></ol><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符包括 &amp;&amp;、||、！。其中 &amp;&amp; 和 || 是双目运算符，实现逻辑与、逻辑或；！是单目运算符，实现逻辑非</p><p>逻辑运算符的优先级为：！运算级别最高，&amp;&amp; 运算高于 || 运算。！运算符的优先级高于算术运算符，而 &amp;&amp; 和 || 运算则低于关系运算符。结合方向是：逻辑非（单目运算符）具有右结合性，逻辑与和逻辑或（双目运算符）具有左结合性。</p><table><thead><tr><th align="center">运算符</th><th align="center">用法</th><th align="center">含义</th><th align="center">结合方向</th><th align="center">实例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">op1&amp;&amp;op2</td><td align="center">逻辑与</td><td align="center">自左到右</td><td align="center">2&gt;1&amp;&amp;3&lt;4</td><td align="center">true</td></tr><tr><td align="center">||</td><td align="center">op1||op2</td><td align="center">逻辑或</td><td align="center">自左到右</td><td align="center">2&lt;1||3&gt;4</td><td align="center">false</td></tr><tr><td align="center">!</td><td align="center">!op</td><td align="center">逻辑非</td><td align="center">自右到左</td><td align="center">!(2&gt;4)</td><td align="center">true</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><strong>本节部分来自c语言中文网:<a href="http://c.biancheng.net/view/784.html" target="_blank" rel="noopener">http://c.biancheng.net/view/784.html</a></strong><br>Java 语言中的位运算符分为位逻辑运算符和位移运算符两类</p><p>位逻辑运算符包含 4 个：&amp;（与）、|（或）、~（非）和 ^（异或）.除了 ~（即位取反）为单目运算符外,其余都为双目运算符</p><p><strong>位逻辑运算符</strong></p><table><thead><tr><th align="center">运算符</th><th align="center">含义</th><th align="center">实例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">按位进行与运算</td><td align="center">4 &amp; 5</td><td align="center">4</td></tr><tr><td align="center">|</td><td align="center">按位进行或运算</td><td align="center">4 | 5</td><td align="center">5</td></tr><tr><td align="center">^</td><td align="center">按位进行异或运算</td><td align="center">4 ^ 5</td><td align="center">1</td></tr><tr><td align="center">~</td><td align="center">按位进行取反运算</td><td align="center">~ 4</td><td align="center">-5</td></tr></tbody></table><p>以下操作全部为转换成二进制后操作</p><p><code>&amp;</code>:参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位同时为 1，那么计算结果才为 1，否则为 0。因此，任何数与 0 进行按位与运算，其结果都为 0。<br><img src="/img/java总笔记/WEI1.jpg"><br><code>|</code>:参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位有一个为 1，那么计算结果就为 1,如果两个都为0,那么计算结果才为0<br><img src="/img/java总笔记/WEI2.jpg"><br><code>^</code>:参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位不同则为1,如果相同则为0<br><img src="/img/java总笔记/WEI3.jpg"></p><p><code>~</code>:只对一个操作数进行运算，将操作数二进制中的 1 改为 0，0 改为 1。<br><img src="/img/java总笔记/WEI4.jpg"></p><p><strong>位移运算符</strong><br>位移运算符用来将操作数向某个方向（向左或者右）移动指定的二进制位数</p><table><thead><tr><th align="center">运算符</th><th align="center">含义</th><th align="center">实例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">&gt;&gt;</td><td align="center">右移位运算符</td><td align="center">8&gt;&gt;1</td><td align="center">4</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移位运算符</td><td align="center">9&lt;&lt;2</td><td align="center">36</td></tr><tr><td align="center">&gt;&gt;&gt;</td><td align="center">无符号右移运算符</td><td align="center">8&gt;&gt;1</td><td align="center">4</td></tr></tbody></table><p>左位移运算符<br>左移位运算符为 «，其运算规则是：按二进制形式把所有的数字向左移动对应的位数，高位移出（舍弃），低位的空位补零。<br><img src="/img/java总笔记/WEI5.jpg"><br>运算得出的结果是原来的两倍</p><p>右移位运算符<br>右位移运算符为 »，其运算规则是：按二进制形式把所有的数字向右移动对应的位数，低位移出（舍弃），高位的空位补零。<br><img src="/img/java总笔记/WEI6.jpg"><br>运算得出的结果是原来的二分之一</p><p>无符号右移运算符<br>无符号右移运算符为<code>&gt;&gt;&gt;</code>,其运算规则是：按二进制形式把除符号位外所有的数字向右移动对应的位数，低位移出（舍弃），高位的空位补零。不存在<code>&lt;&lt;&lt;</code>运算符</p><p>总结:<strong>左移一位后的值变为原来的两倍,而右移一位的值则变为原来的二分之一,当x为非负值时,移位结果为x/2∧n的商的整数部分</strong></p><p><strong>复合位赋值运算符</strong></p><table><thead><tr><th align="center">运算符</th><th align="center">含义</th><th align="center">实例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">&amp;=</td><td align="center">按位与赋值</td><td align="center">num1 &amp;= num2</td><td align="center">等价于 num 1=num 1 &amp; num2</td></tr><tr><td align="center">|=</td><td align="center">按位或赋值</td><td align="center">num1 |= num2</td><td align="center">等价于 num 1=num 1 | num2</td></tr><tr><td align="center">^=</td><td align="center">按位异或赋值</td><td align="center">num1 ^= num2</td><td align="center">等价于 num 1=num 1 ^ num2</td></tr><tr><td align="center">~=</td><td align="center">按位取反赋值</td><td align="center">num1 ~= num2</td><td align="center">等价于 num 1=num 1 ~ num2</td></tr><tr><td align="center">«=</td><td align="center">按位左移赋值</td><td align="center">num1 «= num2</td><td align="center">等价于 num 1=num 1 « num2</td></tr><tr><td align="center">»=</td><td align="center">按位右移赋值</td><td align="center">num1 »= num2</td><td align="center">等价于 num 1=num 1 » num2</td></tr></tbody></table><p>##输入与输出<br>为了增加后面示例程序的趣味性，需要程序能够接收输入，并以适当的格式输出</p><h3 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h3><p>读取”标准输入流”,想要通过控制台进行输入,首先需要构造一个Scanner对象,并与”标准输入流”System.in关联</p><p>而想要构造Scanner对象,必须先导入Scanner包</p><p>将以下语句放在文件的开头<br><code>import java.util.Scanner;</code></p><p>这条语句将已经编译好的包中的类导入文件<br>然后实例化Scanner对象:<br><code>Scanner 对象名 = new Scanner(System.in)</code></p><p>然后就可以使用类中的方法进行输入啦!</p><table><thead><tr><th align="center">方法名称</th><th align="center">返回值类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Scanner(InputStream in)</td><td align="center">Scanner</td><td align="center">用给定的流创建一个Scanner对象</td></tr><tr><td align="center">nextLine( )</td><td align="center">String</td><td align="center">读取输入的下一行内容,可以读取空格</td></tr><tr><td align="center">next( )</td><td align="center">String</td><td align="center">读取输入的下一个单词（以空格作为分隔符)</td></tr><tr><td align="center">nextlnt( )</td><td align="center">int</td><td align="center">读取并转换下一个表示整数字符序列</td></tr><tr><td align="center">nextDouble()</td><td align="center">double</td><td align="center">读取并转换下一个表示整数或浮点数的字符序列</td></tr></tbody></table><p>如果要读取单个字符则需要以下操作<br><code>char c=input.next().charAt(0);</code><br>详解:由表可知next()方法是读取一个单词,返回值为一个字符串,而charAt是String类中的一个方法 ,作用是可以在字符串内根据指定的索引查找字符,而索引为0的字符就是第一个字符,所以可以用来读取单个字符</p><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lucky</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);<span class="comment">// 实例化Scanner对象</span></span><br><span class="line"><span class="keyword">int</span> a = input.nextInt();   <span class="comment">// 读取一个整型数据</span></span><br><span class="line">String b = input.next();     <span class="comment">// 读取一个单词,以空格作为分隔符</span></span><br><span class="line">String c = input.nextLine();   <span class="comment">// 读取一行内容,可以读取空格</span></span><br><span class="line"><span class="keyword">double</span> d = input.nextDouble();     <span class="comment">// 读取一个double类型的</span></span><br><span class="line"><span class="keyword">char</span> e = input.next().charAt(<span class="number">0</span>);   <span class="comment">// 读取单个字符</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>前面可以看到可以使用以下这条可以将变量x对应的数据类型与字符串输出至控制台<br><code>System.out.print(x+&quot;字符串&quot;);</code></p><p>如果想输出并换行<br><code>System.out.println(x+&quot;字符串&quot;);</code></p><p>也可以单独的换行,不输出别的信息<br><code>System.out.println();</code></p><p>JavaSE 5.0 沿用了C语言库函数中的printf方法<br>格式:<br><code>System.out.printf(&quot;格式控制&quot;,输出项1,输出项2,...);</code></p><p>格式控制字符及其功能</p><table><thead><tr><th align="center">转换符</th><th align="center">类型</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">d</td><td align="center">十进制整数</td><td align="center">159</td></tr><tr><td align="center">X</td><td align="center">十六进制整数</td><td align="center">9f</td></tr><tr><td align="center">0</td><td align="center">八进制整数</td><td align="center">237</td></tr><tr><td align="center">f</td><td align="center">定点浮点数</td><td align="center">15.9</td></tr><tr><td align="center">e</td><td align="center">指数浮点数</td><td align="center">1.59e+01</td></tr><tr><td align="center">g</td><td align="center">通用浮点数</td><td align="center">一</td></tr><tr><td align="center">a</td><td align="center">十六进制浮点数</td><td align="center">0xl.fccdp3</td></tr><tr><td align="center">S</td><td align="center">字符串</td><td align="center">Hello</td></tr><tr><td align="center">C</td><td align="center">字符</td><td align="center">H</td></tr><tr><td align="center">b</td><td align="center">布尔</td><td align="center">True</td></tr><tr><td align="center">h</td><td align="center">散列码</td><td align="center">42628b2</td></tr><tr><td align="center">%</td><td align="center">百分号</td><td align="center">%</td></tr><tr><td align="center">n</td><td align="center">与平台有关 的行分隔符</td><td align="center">一</td></tr></tbody></table><p>另外,还可以给printf指定各种标志,标志的作用是控制输出的格式<br>例:<code>.2f</code> 是指输出的时候只保留两个小数</p><p>还可以指定多个标志<br>例:`%,(.2f``  是指输出时使用千分位分隔符并将负数括在括号 里保存两位小数输出</p><p>用于printf的标志</p><table><thead><tr><th align="center">标志</th><th align="center">目的</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">打印正数和负数的符号</td><td align="center">+3333.33</td></tr><tr><td align="center">空格</td><td align="center">在正数之前添加空格</td><td align="center">| 3333.33|</td></tr><tr><td align="center">0</td><td align="center">数字前面补</td><td align="center">0 003333.33</td></tr><tr><td align="center">-</td><td align="center">左对齐</td><td align="center">|13333.33 |</td></tr><tr><td align="center">(</td><td align="center">将负数括在括号内</td><td align="center">(3333.33)</td></tr><tr><td align="center">,</td><td align="center">添加分组分隔符</td><td align="center">3,333.33</td></tr><tr><td align="center">#</td><td align="center">(对于f 格式)包含小数点</td><td align="center">3,333.</td></tr><tr><td align="center">#</td><td align="center">(对于 x 或 0 格式)添加前缀 Ox 或0</td><td align="center">Oxcafe</td></tr><tr><td align="center">$</td><td align="center">给定被格式化的参数索引。例如,％l$d,％l$x 将以十进制和 十六进制格式打印第 1 个参数</td><td align="center">159 9F</td></tr><tr><td align="center">&lt;</td><td align="center">格式化前面说明的数值.例如,％d%&lt;X 以十进制和十六进制打印同一个数值</td><td align="center">159 9F</td></tr></tbody></table><hr><h2 id="分支与循环"><a href="#分支与循环" class="headerlink" title="分支与循环"></a>分支与循环</h2><p>结构化程序化设计里面程序有三种结构: 顺序结构,选择结构,与循环结构</p><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>块是指两个大括号括起来的地方就是一个块,块中有若干Java语句,块确定了变量的作用域,块是可以嵌套的</p><p><strong>在Java中,if语句与循环语句的内部也是一个块,类是一个块,方法也是一个块</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lucky</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">&#123;<span class="comment">//大括号</span></span><br><span class="line"><span class="keyword">int</span> a= i+<span class="number">9</span>;<span class="comment">//这就是一个块,可以使用外一层的变量 i</span></span><br><span class="line">&#125;    <span class="comment">//大括号结束</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个块中定义的变量拥有块作用域,在内部块定义的变量在外部不能用.但<strong>在外层块定义的变量在内层块可以使用</strong></p><p>和c语言不同的是,Java中外层块中定义的变量与内层块中的相同,在c语言中相同名字的变量内层块中的变量作用域会覆盖外层块中的变量作用域,但在Java中不能这么做</p><p>但如果是内部块在先,执行完内部块后,在后面再定义之前在块中定义变量相同的变量名,是可以的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lucky</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">3</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a= <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> c= i + a;   <span class="comment">//可以使用外部块中的变量</span></span><br><span class="line"><span class="comment">//int b = 3;   //不能与外部变量同名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a =<span class="number">0</span>;<span class="comment">//内部块作用域结束,不影响外部块了</span></span><br><span class="line">System.out.println(a);</span><br><span class="line"><span class="comment">//System.out.println(c);   //错误,不能使用内部块中的变量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>程序在运行过程中默认是顺序结构,代码块从上到下一行行执行,分支结构不以默认的顺序结构执行,相当于一条大路出现了小的分支,但最后还是会回到大路</p><p>选择结构简单的说就是,如果条件为真就执行代码块,为假就 执行另一个代码块,或者不执行直接跳过,就像那条小路不是你想要走的,还是继续走大路</p><h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h4><p>格式为</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件表达式)&#123;</span><br><span class="line">    语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最简单的if条件表达式,当条件表达式为真,则执行语句块,若条件表达式为假,则直接跳过语句块执行之后的语句<br>条件表达式可以是逻辑表达式,也可以是单纯的布尔值</p><p>若是不为真想执行另外一些语句呢? 有else</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件表达式)&#123;</span><br><span class="line">    语句块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件表达式为真时执行语句块1,若是条件表达式为假时,则执行else里的语句块,也就是语句块2</p><p>若还想提供多个分支,一个判断不够</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件表达式)&#123;</span><br><span class="line">    语句块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">语句块<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">语句块<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">语句块<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当if之后的条件表达式不成立后,就一条一条判断之后的else if后面的表达式,若else if后面的条件表达式中有为真的,就执行相应代码块,若都为假,就执行else后的语句块,若全部都为真,也只会执行最先判断到为真的</p><p>else语句一般放到最后,表示,以上条件表达式都不为真时要执行的</p><p>当if或者else只有一条语句时,大括号可以省略,但这样会使结构不清晰,所以最好不要这样做</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lucky</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"你有多少万存款?"</span>);</span><br><span class="line"><span class="keyword">int</span> i = input.nextInt();</span><br><span class="line"><span class="keyword">if</span>(i&gt;=<span class="number">500</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"凯迪拉克"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">100</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"帕萨特"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">50</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"伊兰特"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">10</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"奥托"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"捷安特"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择结构是可以嵌套的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件表达式)&#123;</span><br><span class="line">    语句块<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有很重要的一点,<strong>else只会与最近的else相匹配</strong></p><p>在以下这种情况,与else匹配是属于内部的if的,所以最好不要省大括号</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)</span><br><span class="line"><span class="keyword">if</span>(条件表达式)</span><br><span class="line">语句块;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch-case语句"><a href="#switch-case语句" class="headerlink" title="switch case语句"></a>switch case语句</h4><p>分支结构还有另外一种表示语句,那就是switch case语句<br>这种结构可以解决分支太多的情况</p><p>基本语法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">case</span> 值n:</span><br><span class="line">        语句块n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句块n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 语句先计算括号内的值,再依次寻找case后是否有与之计算结果相匹配的值,如果找到了则执行该case后的语句块,然后执行break,跳出switch语句,但如果case后面都没有与之匹配的值,那么就执行default语句后的语句</p><p>case 后面的值可以是字符常量与整型常量,在jdk7之后支持字符串常量,不可以是变量,case与值用空格隔开,值后要加冒号,每个case后的值都是唯一的,不能与其他case后的值重复</p><p>break语句也可以省略,省略后会执行完该case语句后会再执行下一条case语句,因为没有跳出语句,它就就会像顺序结构一样一条条b执行语句,直到遇见break或语句结束</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">14</span>;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">System.out.println(<span class="string">"这个值是14"</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">System.out.println(<span class="string">"这个值是15"</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">System.out.println(<span class="string">"这个值是16"</span>);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"这里没有要找的值"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:<br>这个值是14<br>这个值是15<br>这个值是16<br>这里没有要找的值</p><p>default 语句可以放在switch语句的任何位置,运行结果没有改变,如果default语句在switch语句块的最后,后面的break可以省略,如果在中间或者最前面的话,break是不能省略的,因为如果在中间没有了break,执行完default后还会执行之后的case语句</p><p><strong>if else 与 switch case 的区别</strong></p><ol><li>常量判断上,switch语句比if else 语句的执行效率要高一些,在分支越多的时候,越明显</li><li>在执行结果上,两种语句并无差别,但从实用性上来讲,switch语句不如if语句</li><li>在执行多分支的时候可以用switch语句,其他情况建议用if语句,</li></ol><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>如果想重复执行一段代码直到满足条件,可以使用循环,几乎所有流行的编程语言都又循环</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>while 循环语句可以在一定条件下重复执行一段代码。该语句需要判断一个测试条件，如果该条件为真，则执行循环语句（循环语句可以是一条或多条），否则跳出循环</p><p>基本语法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式)</span><br><span class="line">&#123;</span><br><span class="line">    语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while循环的执行过程是,当执行到while语句块时,先判断括号内的条件表达式是否为true,如果为true则执行语句块,执行完语句块后再回到最初,判断括号内条件表达式是否为true,一直运行,直到条件表达式为false</p><p>值得注意的是:<br><strong>while循环是先判断条件表达式再执行代码块的</strong><br><strong>在while循环内一定要设置改变条件的语句,不然就成了死循环,一直不会退出循环,除非强制停止程序</strong><br><strong>在while的括号后面不能加分号,否则就是一个死循环</strong></p><p>使用循环输出100、95、90、85、…、5</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lucky</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.print(i+<span class="string">"、"</span>);</span><br><span class="line">i=i-<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出: <code>100、95、90、85、80、75、70、65、60、55、50、45、40、35、30、25、20、15、10、5、</code></p><p>今有鸡兔同笼，上有三十五头，下有九十四足，问鸡兔各几只？试编写程序解决这个问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lucky</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(x*<span class="number">2</span>+y*<span class="number">4</span>==<span class="number">94</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">x--;</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"鸡有"</span>+x+<span class="string">"只，兔有"</span>+y+<span class="string">"只"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h4><p>使用while循环是首先检查条件表达式的,里面的代码可能一次都不执行,但do while 语句就解决了这种问题,它与while最大的区别就是do while一定会执行循环体里面的语句至少一次</p><p> 语法:<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    语句块;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件表达式);</span><br></pre></td></tr></table></figure></p><p>例子:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lucky</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"请输入十以内的数字继续循环,输入超过十的数字结束循环"</span>);</span><br><span class="line">i=input.nextInt();</span><br><span class="line">&#125; <span class="keyword">while</span> (i&lt;<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">"结束循环"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中先提示,后输入,输入后判断输入的是否是十以内的数,如果是就继续循环,如果不是就结束循环</p><p>前面我们提到,变量的定义尽量在离第一次使用这个变量最近的地方,那为什么9不定义在do while中呢,因为do while语句也是一个作用域,两个大括号括起来的地方就形成了一个区域,在里面定义的变量只有在那里面可以用,但我们判断的时候使用了,如果定义在里面,就会报错</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for语句可以看做while的简化版,它把初始化,条件,以及迭代语句整合在了括号中,以至于不会忘记设置</p><p><strong>while语句可以实现的for都可以实现,for可以实现的,while一样也可以实现,也就是说,循环之间都是可以转换与嵌套</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(条件表达式<span class="number">1</span>;条件表达式<span class="number">2</span>;条件表达式<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件表达式1: 一般用做参数初始化,例如变量定义 例如  int i=10<br>条件表达式2: 是循环的判断条件,就是while括号里面的那部分 例如 i&lt;20<br>条件表达式3: 一般作为迭代语句,改变判断条件里面那个变量 例如 i++ i–</p><p>执行顺序:<br>先执行条件表达式1,然后判断条件表达式2是否为true,如果为 false则之间跳过循环体语句块和条件表达式3,直接执行for语句下面的语句,若条件表达式2为true,则执行循环体语句块<br>执行完语句块后再执行条件表达式3,执行完后再去判断条件表达式2,若为true则继续执行语句块然后又执行条件表达式3直到条件表达式2为false</p><p>例子:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码用于输出从0到100的数字,先初始化变量i,判断i是否小于100,然后输出i,再然后执行i++,再去判断i是否小于100,直到i不小于100</p><p><strong>在这里变量i也是局部变量,只能在for循环中使用</strong></p><p>输出九九乘法表示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&lt;=i)</span><br><span class="line">System.out.print(i+<span class="string">"*"</span>+j+<span class="string">"="</span>+i*j+<span class="string">"  "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环中的三个条件表达式都是可以省略的,但是中间的分号不能省略,否则就是语法错误</p><p>省略第一个条件表达式: 进入循环中首先执行的语句,这条语句也可以放在for语句之前</p><p>省略第二个条件表达式:省略后需要使用break语句跳出循环,不然会形成死循环,省略了判断条件将默认为真</p><p>省略第三个条件表达式:省略后少了改变条件的语句,也是可以在循环体中加,如果不加也容易造成死循环</p><p>三个条件表达式都省略: 除非有break语句结束循环,否则是一个循环</p><h4 id="循环控制语句break与continue"><a href="#循环控制语句break与continue" class="headerlink" title="循环控制语句break与continue"></a>循环控制语句break与continue</h4><p>为了更好地控制循环走向,java与其他高级编程语言一样,有break与continue两种循环控制语句,但Java的break语句与其他编程语言的稍有不同</p><h5 id="break"><a href="#break" class="headerlink" title="break"></a>break</h5><p>break在英文中是中断的意思,而事实也是如此,之前说到 switch 中的语句break可以跳出switch语句块,循环中的作用也差不多,就是中断循环,不让循环继续下去,在循环体中break之后的语句都不会执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">System.out.println(<span class="string">"这条语句不会执行"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>break语句一般搭配if语句一起使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">10</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">5</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">System.out.println(i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这条语句将0到5输出,因为i加到6时满足if条件,执行了break语句,之间跳出循环了,虽然i等于6,但是因为在输出之前就已经跳出了循环,所以break之后的语句不会执行;</p><p>break语句还可以除了可以跳出switch与循环外,还可以跳出指定循环与语句块</p><p>如果有多重循环嵌套,想跳出的是外层循环,可以用break加标签来实现,这点和c语言不同,c语言是只能跳出此层循环,因为c语言的跳转可以用goto语句实现,而goto在java里被作为了保留字,没有跳转功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a:<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;i&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">break</span> a;</span><br><span class="line">System.out.println(<span class="string">"钟舒艺"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实例使用if语句加break直接跳出外层循环,当跳出后,不会执行里面的任何东西了,直接执行循环之后的语句</p><p>break还可以用来跳出语句块,实现了部分goto的功能;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">be:&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">11</span>;</span><br><span class="line">System.out.println(<span class="string">"跳出语句块"</span>);</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">10</span>)</span><br><span class="line"><span class="keyword">break</span> be;</span><br><span class="line">System.out.println(<span class="string">"这段跳出后不执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实跳出循环也属于跳出语句块,循环本身就是一个语句块,使用break跳出语句块后,这个break之后的语句都不会执行了.同理,if也是语句块,也可以用break跳出,当然,你得在语句块前面加一个标签,标签后面一定要一个冒号</p><p>但是这种方法在实际中并不常用</p><h5 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h5><p>当满足条件后既想跳过在这之后循环体语句,又不想退出这个循环,要继续循环,这个时候可以用continue语句</p><p>continue 在英文中是继续的意思,在Java中表示即刻开始下一次循环</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">System.out.print(i+<span class="string">","</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为1,3,5,7,9<br>此示例的意思是,当i为偶数时,直接进行下一次循环,而忽略了循环里面continue之后的语句,执行完continue后直接跳到for语句的表达式3,然后判断表达式2,从而忽略了<code>System.out.print(i+&quot;,&quot;)</code></p><p>在for循环中使用continue会执行迭代语句,也就是表达式3,但在其他循环中需要注意,不要把迭代语句放到continue之后去,这样可能也会造成死循环</p><p>例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">10</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"钟舒艺"</span>);</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">9</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol><li>循环与选择都可以多层嵌套,理论上可以无限嵌套</li><li>while循环与do while循环注意加迭代语句,否则可能造成死循环</li><li>for语句三个表达式都可以省略,但是两个分号是不能省略的</li><li>break可以跳出switch语句,循环,以及语句块,但跳出外层循环或跳出语句块时要配合标签使用</li><li>continue可以即刻开始下一次循环,所以在while或者do while中不要把迭代语句放在continue之后</li><li>在选择与循环中声明的变量属于局部变量,只能在该语句块中使用</li></ol><p>在循环中还有一个需要注意的地方就是,尽量不要检测两个浮点数是否相等<br>例如:<br><code>for (double x = 0; x != 10; x += 0.1)</code><br>这个语句可能会是一个死循环 ,由于0.1无法用二进制精确的表示,所以，x 将从 9.999 999 999 999 98 跳到 10.099 999 999 999 98</p><p>接下来讲该出现该问题的解决办法</p><h2 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h2><p>前面提到由于double类型与float类型的变量由于无法用无法用二进制精确地表示,会产生精度丢失的问题,这在平常计算中非常不方便</p><p>如果基本的整数和浮点数的精度与长度不能满足需求,那么可以用Java.math包中两个很有用的类:BigInteger和 BigDecimal</p><p>这两个类可以处理包含任意长度数字序列的数值</p><p>BigDecimal实现了任意精度的整数运算,BigInteger实现了任意精度的整数运算</p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>构造器</p><table><thead><tr><th align="center">构造器</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">BigDecimal(int)</td><td align="center">创建一个具有参数所指定整数值的对象。</td></tr><tr><td align="center">BigDecimal(double)</td><td align="center">创建一个具有参数所指定双精度值的对象。</td></tr><tr><td align="center">BigDecimal(long)</td><td align="center">创建一个具有参数所指定长整数值的对象。</td></tr><tr><td align="center">BigDecimal(String)</td><td align="center">创建一个具有参数所指定以字符串表示的数值的对象。</td></tr></tbody></table><p>常用方法</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">add(BigDecimal)</td><td align="center">BigDecimal对象中的值相加，然后返回这个对象。</td></tr><tr><td align="center">subtract(BigDecimal)</td><td align="center">BigDecimal对象中的值相减，然后返回这个对象。</td></tr><tr><td align="center">multiply(BigDecimal)</td><td align="center">BigDecimal对象中的值相乘，然后返回这个对象。</td></tr><tr><td align="center">divide(BigDecimal)</td><td align="center">BigDecimal对象中的值相除，然后返回这个对象。</td></tr><tr><td align="center">toString()</td><td align="center">将BigDecimal对象的数值转换成字符串。</td></tr><tr><td align="center">doubleValue()</td><td align="center">将BigDecimal对象中的值以双精度数返回。</td></tr><tr><td align="center">floatValue()</td><td align="center">将BigDecimal对象中的值以单精度数返回。</td></tr><tr><td align="center">longValue()</td><td align="center">将BigDecimal对象中的值以长整数返回。</td></tr><tr><td align="center">intValue()</td><td align="center">将BigDecimal对象中的值以整数返回。</td></tr></tbody></table><p>没错,为了使用精度准确的BigDecimal,就必须付出一定的代价,那就是使用时必须进行对象的实例化以及不能使用+,-,*,/这些简单的符号进行加减乘除了,必须使用相应的方法</p><p><strong>我们看到 BigDecimal的构造器有这么多个,但是建议都用BigDecimal(String)构造器,因为使用其他构造器可能也会造成精度丢失,甚至比不用 BigDecimal丢失还更大</strong></p><p>使用示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal; <span class="comment">//使用前必须导入i java.math.BigDecimal类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lucky</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">BigDecimal i = <span class="keyword">new</span> BigDecimal(<span class="string">"0.122222"</span>);<span class="comment">//使用BigDecimal(String)构造器实例化对象</span></span><br><span class="line">BigDecimal j = <span class="keyword">new</span> BigDecimal(<span class="string">"0.001"</span>);</span><br><span class="line">i = i.add(j);                  <span class="comment">//使用加法运算</span></span><br><span class="line">System.out.println(i);         <span class="comment">//输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到我们之前的问题</p><p><code>for (double x = 0; x != 10; x += 0.1)</code>这是一个死循环,既然 BigDecimal可以保证精度,那么可以可以使用 BigDecimal来实现这个循环呢</p><p>精度与加减乘除的问题解决了,接下来我们又面临了新的问题,那就是如何判断x是否等于10呢?</p><p>使用简单的<code>==</code>是肯定不行的,因为我们操作的都是已经实例化的对象,而不是基本数据类型,这时又想到判断对象是否相等用的是 equals()方法 ,能不能用equals实现呢</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lucky</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">BigDecimal i = <span class="keyword">new</span> BigDecimal(<span class="string">"0"</span>);</span><br><span class="line">BigDecimal j = <span class="keyword">new</span> BigDecimal(<span class="string">"10"</span>);</span><br><span class="line">BigDecimal k = <span class="keyword">new</span> BigDecimal(<span class="string">"0.1"</span>);</span><br><span class="line"><span class="keyword">for</span> (;!(i.equals(j)); i=i.add(k))&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恭喜你,将再次得到一个无限死循环</p><p>通过查看 BigDecimal类的源码可以发现, equals方法被 BigDecimal类重写了,在判断两个对象值是否相等的同时,还会判断两个 BigDecimal对象的精度是否相同,如果不同返回依然是false,所以不能使用 equals方法判断它们是否相等</p><p>如果要实现判断两个 BigDecimal是否相等,需要用到compareTo()方法<br>返回值 为-1表示小于,返回值为 0表示等于,返回值 为1表示大于</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lucky</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">BigDecimal i = <span class="keyword">new</span> <span class="type">BigDecimal</span>(<span class="string">"0"</span>);</span><br><span class="line">BigDecimal j = <span class="keyword">new</span> <span class="type">BigDecimal</span>(<span class="string">"10"</span>);</span><br><span class="line">BigDecimal k = <span class="keyword">new</span> <span class="type">BigDecimal</span>(<span class="string">"0.1"</span>);</span><br><span class="line"><span class="keyword">for</span> (;i.compareTo(j)!=<span class="number">0</span>; i=i.add(k))&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样,就解决了这个问题</p><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>Java中，由CPU原生提供的整型最大范围是64位long型整数。使用long型整数可以直接通过CPU指令进行计算，速度非常快。</p><p>如果我们使用的整数范围超过了long型怎么办？这个时候，就只能用软件来模拟一个大整数。java.math.BigInteger就是用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数</p><p>使用BigInteger的方法与 BigDecimal无异,都需要先实例化对象,再使用加减乘除的方法进行运算,这些方法与 BigDecimal里面方法的名称一样</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">BigInteger abs()</td><td align="center">返回大整数的绝对值</td></tr><tr><td align="center">BigInteger add(BigInteger val)</td><td align="center">返回两个大整数的和</td></tr><tr><td align="center">BigInteger and(BigInteger val)</td><td align="center">返回两个大整数的按位与的结果</td></tr><tr><td align="center">BigInteger andNot(BigInteger val)</td><td align="center">返回两个大整数与非的结果</td></tr><tr><td align="center">BigInteger divide(BigInteger val)</td><td align="center">返回两个大整数的商</td></tr><tr><td align="center">double doubleValue()</td><td align="center">返回大整数的double类型的值</td></tr><tr><td align="center">float floatValue()</td><td align="center">返回大整数的float类型的值</td></tr><tr><td align="center">BigInteger gcd(BigInteger val)</td><td align="center">返回大整数的最大公约数</td></tr><tr><td align="center">int intValue()</td><td align="center">返回大整数的整型值</td></tr><tr><td align="center">long longValue()</td><td align="center">返回大整数的long型值</td></tr><tr><td align="center">BigInteger max(BigInteger val)</td><td align="center">返回两个大整数的最大者</td></tr><tr><td align="center">BigInteger min(BigInteger val)</td><td align="center">返回两个大整数的最小者</td></tr><tr><td align="center">BigInteger mod(BigInteger val)</td><td align="center">用当前大整数对val求模</td></tr><tr><td align="center">BigInteger multiply(BigInteger val)</td><td align="center">返回两个大整数的积</td></tr><tr><td align="center">BigInteger negate()</td><td align="center">返回当前大整数的相反数</td></tr><tr><td align="center">BigInteger not()</td><td align="center">返回当前大整数的非</td></tr><tr><td align="center">BigInteger or(BigInteger val)</td><td align="center">返回两个大整数的按位或</td></tr><tr><td align="center">BigInteger pow(int exponent)</td><td align="center">返回当前大整数的exponent次方</td></tr><tr><td align="center">BigInteger remainder(BigInteger val)</td><td align="center">返回当前大整数除以val的余数</td></tr><tr><td align="center">BigInteger leftShift(int n)</td><td align="center">将当前大整数左移n位后返回</td></tr><tr><td align="center">BigInteger rightShift(int n)</td><td align="center">将当前大整数右移n位后返回</td></tr><tr><td align="center">BigInteger subtract(BigInteger val)</td><td align="center">返回两个大整数相减的结果</td></tr><tr><td align="center">byte[] toByteArray(BigInteger val)</td><td align="center">将大整数转换成二进制反码保存在byte数组中</td></tr><tr><td align="center">String toString()</td><td align="center">将当前大整数转换成十进制的字符串形式</td></tr><tr><td align="center">BigInteger xor(BigInteger val)</td><td align="center">返回两个大整数的异或</td></tr></tbody></table><hr><h2 id="java数组"><a href="#java数组" class="headerlink" title="java数组"></a>java数组</h2><p>当想要声明多个同一类型的变量时<br><code>int a,b,c,d,e,f,g;</code><br>这样的方式显然比较繁琐,这时我们就可以用到<strong>数组</strong></p><p>数组就是多个同一数据类型元素组成的集合</p><p>数组是Java中的一种<strong>引用数据类型</strong>,跟c语言的数组是一样的,c语言中的指针就相当于Java中的引用</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>一维数组可以存放上千万的变量,并且这些变量的数据类型都是相同的,并且可以通过整型的下标来访问它们</p><p>在声明一维数组时,要指定数组的数据类型和数组的名字<br>数组的命名规范与变量一致</p><p>例如:<br><code>int a[];</code><br>意思是声明了一个名字为a的的整型数组,不过这条语句只是声明了一个数组变量,并没有初始化成一个真正的数组,应该使用new运算符开辟这个数组的空间</p><p><code>int a[] = new int[5];</code></p><p>这条语句声明了一个名字为a的整型数组,并且分配了五个空间给它,在这之后可以使用这五个空间,但只能存整型的数据</p><p>如果要使用它们</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lucky</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];  <span class="comment">//声明变量并开辟空间</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">0</span>;   <span class="comment">//给变量赋值</span></span><br><span class="line">a[<span class="number">1</span>]=<span class="number">1</span>;   <span class="comment">//给变量赋值</span></span><br><span class="line">a[<span class="number">2</span>]=<span class="number">2</span>;   <span class="comment">//给变量赋值</span></span><br><span class="line">System.out.println(a[<span class="number">0</span>]+<span class="string">","</span>+a[<span class="number">1</span>]+<span class="string">","</span>+a[<span class="number">2</span>]);<span class="comment">//使用变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EXCEL常用函数总结</title>
      <link href="/2019/07/26/EXCEL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
      <url>/2019/07/26/EXCEL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-单条件求和——SUMIF-函数"><a href="#1-单条件求和——SUMIF-函数" class="headerlink" title="1.单条件求和——SUMIF 函数"></a>1.单条件求和——SUMIF 函数</h1><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式:"></a>语法格式:</h3><p><code>=sumif(range，criteria，sum_range)</code><br>Sumif（条件区域，求和条件，实际求和区域）<br>注:第二个求和条件参数在第一个条件区域里。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h3><p>统计书店的销售量<br><img src="/img/EXCEL常用函数总结/SUMIF.png"></p><p>要求是统计鼎盛书店的销量,公式:<br><code>=SUMIF(C3:C636,G4,E3:E636)</code><br>1.条件区域:第一个参数条件区域是c列c3至c636,这里是书店名称</p><p>2.求和条件:第二个参数求和条件是G4,只有在条件区域里满足G4的条件才可以进行求和,而这里的就是只有书店名称是鼎盛书店的才能被求和,其他的则自动忽略</p><p>3.实际求和区域:要在此区域选择满足书店名称等于鼎盛书店的的销量,然后求和</p><h1 id="2-多条件求和—SUMIFS函数"><a href="#2-多条件求和—SUMIFS函数" class="headerlink" title="2.多条件求和—SUMIFS函数"></a>2.多条件求和—SUMIFS函数</h1><h3 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h3><p><code>=sumifs(sum_range, criteria_range1, criteria1, [criteria_range2, criteria2], ...)</code><br>SUMIFS(实际求和区域，第一个条件区域，第一个对应的求和条件，第二个条件区域，第二个对应的求和条件，第N个条件区域，第N个对应的求和条件）</p><p>主要功能：对指定单元格区域中符合多组条件的单元格求和。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>统计《MSOffice高级应用》图书在2012年的总销售额<br><img src="/img/EXCEL常用函数总结/SUMIFS.png"></p><p>公式:<br><code>=SUMIFS(订单明细表!,表3[图书名称]，&quot;《MS Ofice高级应用》&quot;，表3[日期]，&quot;&gt;=2012-1-1&quot;,表3[日期],&quot;&lt;=2012-12-31&quot;)</code></p><p>本题中参数含义如下：<br>参数1-求和区域：参加求和的实际单元格区域，即销售额（小计）列；<br>参数2-条件区域1：第1组条件中指定的区域，即图书名称列；<br>参数3-条件1：第1组条件中指定的条件，即要查找的图书，为《MS Office高级应用》；<br>参数4-条件区域2：第2组条件中指定的区域，即日期列；<br>参数5-条件2：第2组条件中指定的条件，先设条件为大于等于2012-01-01；<br>参数6-条件区域3：第3组条件中指定的区域，即日期列；<br>参数7-条件3：第3组条件中指定的条件，再设条件为小于等于2012-12-31；<br>还可以有其他多组条件<br>注:直接输入公式的话条件需要打双引号””括起来</p><h1 id="3-查找函数—VLOOKUP"><a href="#3-查找函数—VLOOKUP" class="headerlink" title="3.查找函数—VLOOKUP"></a>3.查找函数—VLOOKUP</h1><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><p><code>VLOOKUP(lookup_value,table_array, col_index_num, [range_lookup])</code><br>VLOOKUP(查找目标,查找的范围,返回值的列数,精确或模糊查找)</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>使用VLOOKUP函数完成图书名称的自动填充。图书名称“和”图书编号”的对应关系在”编号对照”工作表中。<br><img src="/img/EXCEL常用函数总结/VLOOKUP1.png"><br><img src="/img/EXCEL常用函数总结/VLOOKUP2.png"></p><p>公式<br>=VLOOKUP([@图书编号],表2,2,0)<br>参数1-查找目标：“D3”。将在参数2指定区域的第1列中查找与D3相同的单元格。<br>参数2-查找范围：“编号对照！SAS2.SCS19°表示“编号对照”工作表中的A2：C19数据区域。注意：查找目标一定要在该区域的第一列。<br>参数3-返回值的列数：“2表示参数2中工作表的第2列。如果在参数2中找到与参数1相同的单元格，则返回第2列的内容。<br>参数4-精确或模糊查找：决定查找精确匹配值还是近似匹配值。第4个参数如果值为0或FALSE则表示精确查找，如果找不到精确匹配值，则返回错误值#/A。如果值为1或TRUE，或者省略时，则表示模糊查找。</p><h1 id="4-RANK排名函数-绝对引用"><a href="#4-RANK排名函数-绝对引用" class="headerlink" title="4.RANK排名函数(绝对引用)"></a>4.RANK排名函数(绝对引用)</h1><h3 id="语法格式-2"><a href="#语法格式-2" class="headerlink" title="语法格式"></a>语法格式</h3><p><code>=rank(number,ref,[order])</code><br>number ——参与排名的数值<br>ref ——排名的数值区域<br>order——有1和0两种。0——从大到小排名（降序），1——从小到大排名（升序）<br>0默认不用输入，得到的就是从大到小的排名</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>按成绩由高到底的顺序统计每个学生的总分排名<br><img src="/img/EXCEL常用函数总结/RANK.png"></p><p>公式<br><code>=RANK(J3,$J$3:$J$46,0)</code><br>参数1:参与排名的数 题目中是J3,也就是608分<br>参数2:参与排名的区域,题中是整个总分列<br>注意: 此处要用绝对引用,若不用绝对引用,则填充时此区域会随着行的改变而改变<br>参数3:0,也就是从大到小排名</p><h1 id="5-字符串截取函数—MID"><a href="#5-字符串截取函数—MID" class="headerlink" title="5.字符串截取函数—MID"></a>5.字符串截取函数—MID</h1><h3 id="语法格式-3"><a href="#语法格式-3" class="headerlink" title="语法格式"></a>语法格式</h3><p><code>=MID(text,start_num,num_chars)</code><br>=MID(字符串,第几位开始,截取几位)<br>注意:截取的那部分单元格必须是文本格式</p><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>截取身份证号码的出生日期<br><img src="/img/EXCEL常用函数总结/MID.png"></p><p>公式<br><code>=MID(C2,7,4)&amp;&quot;年&quot;&amp;MID(C2,11,2)&amp;&quot;月&quot;&amp;MID(C2,13,2)&amp;&quot;日&quot;</code><br>MID(C2,7,4)表示从C2单元格的第七位开始截取4位,<br>其后以此类推<br>若须加字符得用&amp;号连接并打双引号</p><h1 id="选择函数—IF"><a href="#选择函数—IF" class="headerlink" title="选择函数—IF"></a>选择函数—IF</h1><h3 id="语法格式-4"><a href="#语法格式-4" class="headerlink" title="语法格式"></a>语法格式</h3><p><code>=IF(logical_test,[Value_if_true],[value_if_false])</code><br>=IF(条件,条件成立时执行,条件不成立时执行)</p><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>判断成绩是否属于优秀<br><img src="/img/EXCEL常用函数总结/IF.png"></p><p>公式:<br><code>=IF(A2&gt;=90,&quot;优秀&quot;,&quot;不优秀&quot;)</code><br>如果A2大于或等于90分,就在单元格中填入优秀,若不成立的话,就填入不优秀<br>注:若是要填入字符串的话要打双引号哦</p><h1 id="除余函数—MOD以及公式的嵌套使用"><a href="#除余函数—MOD以及公式的嵌套使用" class="headerlink" title="除余函数—MOD以及公式的嵌套使用"></a>除余函数—MOD以及公式的嵌套使用</h1><h3 id="语法格式-5"><a href="#语法格式-5" class="headerlink" title="语法格式"></a>语法格式</h3><p><code>=MOD(number,divisor)</code><br>=MOD(被除数,除数)<br>注:此函数一般不单独使用,常和其他函数组合起来使用<br>如果 divisor 为零，函数 MOD 返回错误值 #DIV/0!<br>若有符数,则结果与除数符号相同<br>例:10与3的余数为1<br><img src="/img/EXCEL常用函数总结/MOD1.png"></p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>由身份证号码判断性别<br><img src="/img/EXCEL常用函数总结/MOD2.png"></p><p>公式:<br><code>=IF(MOD(MID(C2,17,1),2)=1,&quot;男&quot;,&quot;女&quot;)</code><br>1.用MID函数截取身份证号码第十七位开始截取一位<br>‘MID(身份证号码,第十七位开始,截取1位)<br>2.用MOD函数判断那第十七位除以2<br>MOD(截取后的第十七位,被除数)’ 3.用IF函数判断余数是否为1,若为1则为奇数,是男生,若不为1,则为偶数,是女生 ‘ IF(余数是否等于1,是的话为男,不是的话为女)</p><h1 id="取整函数–INT"><a href="#取整函数–INT" class="headerlink" title="取整函数–INT"></a>取整函数–INT</h1><h3 id="语法格式-6"><a href="#语法格式-6" class="headerlink" title="语法格式"></a>语法格式</h3><p><code>=INT(number)</code><br>注:此函数不进行四舍五入,直接截取</p><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>对A1单元格进行取整<br><img src="/img/EXCEL常用函数总结/INT.png"></p><h1 id="日期函数–TODAY"><a href="#日期函数–TODAY" class="headerlink" title="日期函数–TODAY"></a>日期函数–TODAY</h1><h3 id="语法格式-7"><a href="#语法格式-7" class="headerlink" title="语法格式"></a>语法格式</h3><p><code>=TODAY()</code><br>获取当前日期<br><img src="/img/EXCEL常用函数总结/TODAY1.png"></p><h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>根据出生日期求年龄<br><img src="/img/EXCEL常用函数总结/TODAY2.png"><br>公式:<br><code>=INT((TODAY()-E2)/365)</code><br>用今天的日期减去出生日期的天数再除去365天再取整</p><h1 id="计算日期间隔函数–DATEDIF"><a href="#计算日期间隔函数–DATEDIF" class="headerlink" title="计算日期间隔函数–DATEDIF"></a>计算日期间隔函数–DATEDIF</h1><h3 id="语法格式-8"><a href="#语法格式-8" class="headerlink" title="语法格式"></a>语法格式</h3><p><code>=DATEDIF(start_date,end_date,unit)</code><br>Start_date 为一个日期，它代表时间段内的第一个日期或起始日期。(起始日期必须在1900年之后)<br>End_date 为一个日期，它代表时间段内的最后一个日期或结束日期<br>Unit 为所需信息的返回类型,例如:y就是年,m是月,d是天<br>注:结束日期必须大于起始日期</p><h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><p>根据出生日期求到2017年-1月-1日年的年龄<br><img src="/img/EXCEL常用函数总结/DATEDIF.png"></p><p>公式<br><code>=DATEDIF(C2,&quot;2017/1/1&quot;,&quot;y&quot;)</code><br>第一个参数是起始日期,第二个参数是结束日期2017年1月1日,第三个参数是返回值类型y是年<br>DATEDIF函数是Excel隐藏函数，其在帮助和插入公式里面没有</p>]]></content>
      
      
      <categories>
          
          <category> OFFICE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EXCEL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
