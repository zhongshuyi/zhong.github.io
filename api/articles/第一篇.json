{"title":"傲娇的寄存器变量","slug":"第一篇","date":"2019-07-19T01:01:19.000Z","updated":"2019-07-23T02:49:07.664Z","comments":true,"path":"api/articles/第一篇.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>变量通常储存在计算机内存中。如果幸运的话，寄存器变量储存在CPU的寄存器中，或者概括地说，储存在最快的可用内存中。与普通变量相比，访问和处理这些变量的速度更快。由于寄存器变量储存在寄存器而非内存中，所以无法获取寄存器变量的地址。绝大多数方面，寄存器变量和自动变量都一样。也就是说，它们都是块作用域、无链接和自动存储期。</p>\n<h2 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h2><p>使用存储类别说明符register便可声明寄存器变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> main（<span class=\"keyword\">void</span>)</span><br><span class=\"line\"><span class=\"keyword\">register</span> <span class=\"keyword\">int</span> quick;</span><br></pre></td></tr></table></figure>\n\n<p>我们刚才说“如果幸运的话”，是因为声明变量为register类别与直接命令相比更像是一种请求。编译器必须根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略你的请求，所以可能不会如你所愿。在这种情况下，寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地址运算符。<br>在函数头中使用关键字register，便可请求形参是寄存器变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> macho（<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> n）</span><br></pre></td></tr></table></figure>\n\n<p>可声明为register的数据类型有限。例如，处理器中的寄存器可能没有足够大的空间来储存double类型的值。<br>[tupian][\\static\\images\\1.jpg]</p>\n","categories":[],"tags":[{"name":"c语言","slug":"c语言","count":1,"path":"api/tags/c语言.json"}]}